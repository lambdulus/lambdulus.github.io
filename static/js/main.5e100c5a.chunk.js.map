{"version":3,"sources":["Types.ts","untyped-lambda-integration/Types.ts","untyped-lambda-integration/TreeComparator.ts","misc/index.ts","untyped-lambda-integration/AppTypes.ts","Constants.ts","components/TopBar.tsx","components/MenuBar.tsx","markdown-integration/AppTypes.ts","components/PickBoxTypeModal.tsx","components/CreateBox.tsx","untyped-lambda-integration/ReactPrinter.tsx","untyped-lambda-integration/ReductionMessage.tsx","untyped-lambda-integration/Step.tsx","untyped-lambda-integration/InactiveExpression.tsx","components/Editor.tsx","components/DebugControls.tsx","untyped-lambda-integration/Expression.tsx","untyped-lambda-integration/ExpressionBox.tsx","untyped-lambda-integration/MacroList.tsx","untyped-lambda-integration/ExerciseBox.tsx","untyped-lambda-integration/Settings.tsx","untyped-lambda-integration/EmptyExpression.tsx","untyped-lambda-integration/UntypedLambdaBox.tsx","markdown-integration/Note.tsx","empty-integration/index.tsx","components/Box.tsx","untyped-lambda-integration/BoxTopBar.tsx","markdown-integration/BoxTopBar.tsx","empty-integration/BoxTopBar.tsx","components/BoxTitleBar.tsx","components/BoxContainer.tsx","screens/Notebook.tsx","misc/UserGuide.ts","screens/Help.tsx","screens/Settings.tsx","screens/NotebookList.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["BoxType","Screen","PromptPlaceholder","UntypedLambdaType","StepValidity","EvaluationStrategy","TreeComparator","roots","macrotables","translator","Map","equals","context","this","compare","left","right","Lambda","backup","entries","set","argument","name","Application","Macro","ChurchNumeral","Variable","has","get","console","log","toString","type","mapLeftFromTo","from","to","sequence","fn","result","Array","e","i","reportEvent","category","action","label","window","ga","getAll","send","exception","CODE_NAME","defaultSettings","UNTYPED_LAMBDA","SLI","expandStandalones","strategy","NORMAL","SDE","toMacroMap","definitions","mNames","reduce","acc","def","split","body","trim","length","Error","tokens","tokenize","lambdaLetters","singleLetterVars","macromap","ast","parse","createNewUntypedLambdaBoxFromSource","source","subtype","macrotable","EMPTY","__key","Date","now","title","minimized","settingsOpen","expression","history","isRunning","breakpoints","timeoutID","undefined","timeout","macrolistOpen","editor","placeholder","content","syntaxError","macros","Object","map","join","message","validity","CORRECT","userInput","isNormal","astCopy","clone","findSimplifiedReduction","strategyToEvaluator","nextReduction","None","lastReduction","step","isNormalForm","exerciseStep","EXERCISE","EVAL_MODE","createNewUntypedLambdaBoxFromSource2","decodeUntypedLambdaState","box","untypedLambdaBox","decodedFirst","decodeUntypedLambdaFast","index","decodedNth","reduction","decodeUntypedLambdaExpression","GLOBAL_SETTINGS_ENABLER","evaluator","Expansion","target","newAst","perform","newreduction","parent","treeSide","M","expanded","newperformevaluation","Alpha","findRedexIn","_","beta","redex","identifier","ASTReductionType","BETA","arity","getFnArgNames","arit","macroname","includes","getArityOfKnownMacro","macroAppRedex","basepoint","tree","extender","NormalMacroRedexExtender","MacroBeta","applications","parents","extendMacroAppRedex","APPLICATIVE","app","argreduction","argperformevaluation","lastapp","lastparent","appParent","shift","Child","Left","Right","reducer","reduced","macro","macroIsSingleStep","evaluateReduction","tryMacroContraction","resAST","isPeanoNumber","isChurchNumeral","n","s","z","peanoToNumber","churchNumeralToNumber","churchArgNames","builtinMacros","definition","macroast","ALPHA","alpha","conversions","some","lambda","ETA","eta","EXPANSION","expansion","GAMA","macrobeta","found","visit","application","push","variable","ASTVisitor","NormalEvaluator","ApplicativeEvaluator","OPTIMISATION","OptimizeEvaluator","ABSTRACTION","NormalAbstractionEvaluator","InitNotebookState","boxList","activeBoxIndex","NaN","focusedBoxIndex","settings","UNTYPED_CODE_NAME","UntypedLambdaDefaultSettings","locked","menuOpen","editingName","persistent","EmptyAppState","notebookList","currentNotebook","currentScreen","MAIN","darkmode","loadSettingsFromStorage","serialized","localStorage","getItem","deserialized","JSON","key","value","error","loadAppStateFromStorage","maybeState","setItem","stringify","state","decodeNotebook","decode","updateAppStateToStorage","updateNotebookStateToStorage","notebook","arr","TopBar","props","onImport","onClearWorkspace","onScreenChange","onDarkModeChange","ntbk","link","data","Blob","URL","createObjectURL","createURL","className","onClick","SETTINGS","href","download","setTimeout","id","accept","onChange","event","files","file","reader","FileReader","onload","readAsText","onFiles","htmlFor","MenuBar","rel","HELP","onMarkDownBlur","isEditing","PickBoxTypeModal","addNew","untLSettings","addLambdaBox","stopPropagation","addMDBox","MARKDOWN","note","caretPosition","CreateBox","modalOpen","setState","Component","ReactPrinter","rendered","redexesFound","accumulator","isBreakpoint","conversion","args","Symbol","broken","Set","printMultiLambda","node","leftClassName","rightClassName","Beta","Gama","churchNumber","redexClass","redexes","ReductionMessage","StepMemo","memo","Step","lastStep","StepWrapper","stepRecord","addBreakpoint","children","newast","printer","print","INCORRECT","substr","InactiveExpression","ActionType","Editor","submitOnEnter","shouldReplaceLambda","onContent","onEnter","onShiftEnter","onCtrlEnter","replace","InputField","onKeyDown","shiftKey","ctrlKey","preventDefault","lines","onKeyDownCapture","height","Math","max","min","language","theme","options","formatOnPaste","minimap","enabled","renderLineHighlight","scrollBeyondLastLine","overviewRulerBorder","scrollbar","editorDidMount","monaco","focus","DebugControls","document","onkeydown","altKey","metaKey","onStep","onRun","runMessage","disabled","PureComponent","Expression","bind","shouldShowDebugControls","isExercise","array","Uint32Array","crypto","getRandomValues","addBox","createBoxFrom","onExecute","style","breakpoint","setBoxState","brkpts","filter","brk","ExpressionBox","onSimplifiedStep","onStop","shouldBreak","onSimplifiedRun","isActive","isNowNormalForm","etaEvaluator","msg","pop","arityBreakpoint","find","clearTimeout","add","normal","MacroList","macroTable","macroName","macroExpression","ExerciseBox","onSubmitExpression","parseExpression","onExerciseStep","onSimplifiedExerciseStep","errorMessage","match","newMacrotable","userAst","VALIDATE_MODE","Settings","change","settingsEnabled","SLI_E","strat_E","uniq","random","checked","EmptyExpression","isMinimized","onDebug","onExercise","UntypedLambdaBox","isFocused","ref","elem","boundingRect","getBoundingClientRect","viewportHeight","innerHeight","bottom","scrollIntoView","ORDINARY","renderBoxContent","Note","Empty","Box","updateBoxState","addBoxAfter","BoxTopBar","EmptyTopBar","BoxTitleBar","where","shareLinkOpen","removeBox","contentEditable","suppressContentEditableWarning","onBlur","textContent","searchParams","location","encodeURI","url","host","navigator","clipboard","writeText","onMouseDownCapture","resetState","resetUntypedLambdaBox","BoxContainer","isActiveBox","isFocusedBox","makeActive","addBoxBefore","boxTypeClassName","mapBoxTypeToStr","onMouseDown","Notebook","insertBefore","insertAfter","createBoxFromURL","updateURL","boxState","boxListCopy","splice","updateNotebook","newIndex","patch","Help","guide","process","SettingsScreen","updateSettings","untypedSettings","UNTYPED_GLOBAL_SETTINGS_ENABLER","unTypLSet","NotebookList","onSelectNotebook","onRemoveNotebook","onUpdateNotebook","onAddNotebook","prompt","App","setScreen","changeNotebook","addNotebook","removeNotebook","editNotebookName","changeNotebookName","stopEditingNotebook","importNotebook","clearWorkspace","selectNotebook","updateNthNotebook","toggleDarkMode","createNotebookFromURL","urlSearchParams","strat","sli","sub","decodeURI","createNewNotebookWithBox","pushState","ex","replaceState","NOTEBOOKS","screen","createNewNotebook","Number","isNaN","newSettings","confirm","Boolean","hostname","ReactDOM","render","getElementById","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.5e100c5a.chunk.js","sourcesContent":["import { UntypedLambdaState, UntypedLambdaSettings } from \"./untyped-lambda-integration/Types\"\nimport { NoteState } from \"./markdown-integration/AppTypes\"\n\nexport enum BoxType {\n  UNTYPED_LAMBDA = 'UNTYPED_LAMBDA',\n  LISP = 'LISP',\n  MARKDOWN = 'MARKDOWN',\n}\n\nexport enum Screen {\n  MAIN,\n  HELP,\n  SETTINGS,\n  NOTEBOOKS, // TODO: this will be the final solution to the `Multiple Notebooks` problem\n}\n\nexport interface AbstractBoxState {\n  type : BoxType,\n  __key : string, \n  title : String,\n  minimized : boolean,\n  settingsOpen : boolean,\n}\n\nexport interface AbstractSettings {\n  type : BoxType,\n}\n\nexport interface LispBox extends AbstractBoxState {\n  // TODO: delete this placeholder and implement it\n}\n\nexport interface LispSettings extends AbstractSettings {\n  // TODO: delete this placeholder and implement it\n}\n\nexport type BoxState = UntypedLambdaState | LispBox | NoteState // or other things in the future\n\nexport type Settings = UntypedLambdaSettings | LispSettings // or other things in the future\n\n// TODO: this needs to be reconsidered\nexport interface GlobalSettings {\n  // [UNTYPED_CODE_NAME] : UntypedLambdaSettings\n  [key : string] : Settings\n}\n\nexport interface NotebookState {\n  boxList : Array<BoxState>\n  activeBoxIndex : number\n  focusedBoxIndex : number | undefined\n\n  locked : boolean\n  menuOpen : boolean\n\n  settings : GlobalSettings // TODO: refactor to use the Dictionary\n\n  __key : string\n  name : string\n  editingName : boolean\n  persistent : boolean\n}\n\nexport interface AppState {\n  notebookList : Array<NotebookState>,\n  currentNotebook : number,\n  currentScreen : Screen,\n  darkmode : boolean\n}\n","import { AbstractSettings, BoxType, AbstractBoxState } from \"../Types\"\nimport { AST, ASTReduction, ASTReductionType, NormalEvaluator, ApplicativeEvaluator, OptimizeEvaluator, MacroMap } from \"@lambdulus/core\"\n\n\nexport enum PromptPlaceholder {\n  INIT = 'Type λ (as \\\\) expression and hit enter',\n  EVAL_MODE = 'Hit enter for next step',\n  VALIDATE_MODE = 'Write next step and hit enter for validation',\n  MACRO = 'Define Macro like: `NAME := [λ expression]` and hit enter',\n  NOTE = 'Type note and hit shift enter'\n}\n\nexport enum UntypedLambdaType {\n  EMPTY = 'EMPTY',\n  ORDINARY = 'ORDINARY',\n  EXERCISE = 'EXERCISE',\n}\n\nexport type Breakpoint = {\n  type : ASTReductionType,\n  context : AST,\n  broken : Set<AST>,\n}\n\nexport interface StepRecord {\n  ast : AST\n  lastReduction : ASTReduction | null\n  step : number\n  message : StepMessage\n  isNormalForm : boolean\n  exerciseStep : boolean\n}\n\nexport interface StepMessage {\n  message : String\n  validity : StepValidity\n  userInput : String\n}\n\nexport enum StepValidity {\n  CORRECT,\n  INCORRECT\n}\n\n\nexport enum EvaluationStrategy {\n  NORMAL = 'Normal Evaluation',\n  APPLICATIVE = 'Applicative Evaluation',\n  OPTIMISATION = 'Optimisation - η Conversion',\n  ABSTRACTION = 'Abstraction / Simplified Evaluation'\n}\n\nexport type UntypedLambdaState = UntypedLambdaExpressionState // | UntypedLambdaMacroState\n\n// TODO: consider abstract Untype Lambda State which will hold all common members\n\nexport interface UntypedLambdaExpressionState extends AbstractBoxState {\n  __key : string\n  type : BoxType\n\n  subtype : UntypedLambdaType\n  expression : string\n  ast : AST | null\n  history : Array<StepRecord>\n  isRunning : boolean\n  breakpoints : Array<Breakpoint>\n  timeoutID : number | undefined\n  timeout : number\n  // isExercise : boolean\n  \n  strategy : EvaluationStrategy\n  SDE : boolean // Semantics Drive Evaluation (Strategy) -- formerly called Simplified Strategy\n  SLI : boolean\n  expandStandalones : boolean\n\n  macrolistOpen : boolean // this is gonna go out\n  macrotable : MacroMap // this is gonna go out - WHY? I don't think so - it's gonna stay\n  \n  editor : {\n    placeholder : string\n    content : string\n    syntaxError : Error | null\n  }\n}\n\nexport interface UntypedLambdaSettings extends AbstractSettings {\n  SLI : boolean\n  expandStandalones : boolean\n  strategy : EvaluationStrategy\n  SDE : boolean\n}\n\nexport type SettingsEnabled = {\n  SLI : boolean\n  expandStandalones : boolean\n  strategy : boolean\n}\n\nexport type Evaluator = NormalEvaluator | ApplicativeEvaluator | OptimizeEvaluator\n","import { AST, Lambda, Application, Macro, ChurchNumeral, Variable, MacroMap } from \"@lambdulus/core\"\n\n///////////////////////////////////////////////////////////////////////////////////////\n\ntype Pair<T> = [T, T]\n// type Triple<T> = [T, T, T]\n\n\n// TODO: fix the public equals interface, maybe public get and private set?\n// maybe implement public get method and bool itself leave private?\n//\n// first I need more trees, I need the previous AST\nexport class TreeComparator {\n  private translator : Map<string, string> = new Map()\n  public equals : boolean = true\n  private context : Pair<AST>\n\n  constructor (readonly roots : Pair<AST>, readonly macrotables : Pair<MacroMap>) {\n    [ ...this.context ] = roots\n    // TODO: I need to compare roots first\n    this.compare()\n  }\n\n  compare () : void {\n    /**\n    TODO: compare need to compare both children if got\n    if one of them is incorrect\n    then solve that problem\n    if both of them is incorrect\n    then solve both problems and then decide how both come together\n\n    then I have an instance of knowledge system\n    I can fire up that system in this context (this node with invalid children)\n    system will need to get instance of something to call methods on\n    because system needs to ask questions - like, is this possible,\n    is this error applicable?\n    so instead of human, code will look up the AST and answer the questions\n    so it will be some kind of class which is able to observe all 3 ASTs at the same time\n    it will also have implemented query methods,\n    probably wont be many of them, just few\n    **/\n    \n    const [ left, right ] : Pair<AST> = this.context\n\n    if (left instanceof Lambda && right instanceof Lambda) {\n      const backup : Map<string, string> = new Map(this.translator.entries())\n\n      this.translator.set(left.argument.name(), right.argument.name())\n      this.context = [ left.right, right.right ]\n      this.compare()\n\n      this.translator = backup\n    }\n    else if (left instanceof Application && right instanceof Application) {\n      this.context = [ left.left, right.left ]\n      this.compare()\n\n      if ( ! this.equals) {\n        return\n      }\n\n      this.context = [ left.right, right.right ]\n      this.compare()\n    }\n    else if (left instanceof Macro && right instanceof Macro) {\n      if (this.macrotables[0][left.name()] === this.macrotables[1][right.name()]) {\n        // this means that both macros are defined identicaly\n        // their names migh differ, but they are letter by letter defined as the same thing\n        this.equals = true\n        return\n      }\n      this.equals = left.name() === right.name()\n    }\n    else if (left instanceof ChurchNumeral && right instanceof ChurchNumeral) {\n      this.equals = left.name() === right.name()\n    }\n    else if (left instanceof Variable && right instanceof Variable) {\n      if (this.translator.has(left.name())) {\n        this.equals = this.translator.get(left.name()) === right.name()\n      }\n      else {\n        this.equals = left.name() === right.name()\n      }\n    }\n    else {\n      this.equals = false\n      console.log('something is not equal')\n      console.log(left.toString(), left.type)\n      console.log(right.toString(), right.type)\n    }\n  }\n}","export function debounce (fn : Function, treshold : number)\n : [ (...args : Array<any>) => void, () => void ] {\n  let timer : number\n  \n  return [\n    function debounced (...args : Array<any>) : void {\n      window.clearTimeout(timer)\n\n      timer = window.setTimeout(() => {\n        fn(...args)\n      }, treshold)\n    },\n    function cancel () : void {\n      window.clearTimeout(timer)\n    }\n  ]\n}\n\n// TODO: remove?\n// export function getSavedMacros () : MacroMap {\n//   return JSON.parse(window.localStorage.getItem('macrotable') || '{}')\n// }\n\nexport function trimStr (str : string) : string {\n  return str.trim()\n}\n\nexport function mapLeftFromTo(\n  from : number,\n  to : number,\n  sequence : Array<any>,\n  fn : (...args : Array<any>) => any) {\n    const result : Array<any> = new Array(to - from + 1)\n\n    for (let e = 0, i = from; i <= to; ++i) {\n      result[e++] = fn(sequence[i], i)\n    }\n\n    return result\n  }\n\n// TODO: remove?\n// export const HANDY_MACROS : MacroMap = {\n//   // 'Y' : '(λ f . (λ x . f (x x)) (λ x . f (x x)))',\n//   // 'Z' : '(λ f . (λ y . f (λ z . y y z)) (λ y . f (λ z . y y z)))',\n//   // FACT : '(Y (λ f n . (<= n 1) 1 (* n (f (- n 1)))))',\n//   // FACCT : '(λ n . (Y (λ f n a . IF (= n 1) a (f (- n 1) (* n a)))) (- n 1) (n))',\n//   // FIB : '(Y (λ f n . (= n 0) 0 ((= n 1) 1 ( + (f (- n 1)) (f (- n 2))))))',\n//   // // SHORTLIST : 'CON 3 (CONS 5 (CONS 1 NIL))',\n//   // // LONGLIST :  '(CONS 3 (CONS 5 (CONS 1 (CONS 10 (CONS 7 (CONS 2 (CONS 4 (CONS 9 (CONS 4 (CONS 6 (CONS 8 NIL)))))))))))',\n//   // APPEND : 'Y (λ fn listA listB . IF (NULL listA) (listB) (CONS (FIRST listA) (fn (SECOND listA) listB)))',\n//   // LISTGREQ : 'Y (λ fn piv list . IF (NULL list) (NIL) ( IF (>= (FIRST list) piv) (CONS (FIRST list) (fn piv (SECOND list))) (fn piv (SECOND list)) ) )',\n//   // LISTLESS : 'Y (λ fn piv list . IF (NULL list) (NIL) ( IF (< (FIRST list) piv) (CONS (FIRST list) (fn piv (SECOND list))) (fn piv (SECOND list)) ) )',\n//   // LISTGR : 'Y (λ fn piv list . IF (NULL list) (NIL) ( IF (> (FIRST list) piv) (CONS (FIRST list) (fn piv (SECOND list))) (fn piv (SECOND list)) ) )',\n//   // LISTEQ : 'Y (λ fn piv list . IF (NULL list) (NIL) ( IF (= (FIRST list) piv) (CONS (FIRST list) (fn piv (SECOND list))) (fn piv (SECOND list)) ) )',\n//   // QUICKSORT : 'Y (λ fn list . IF (NULL list) (NIL) ( IF (NULL (SECOND list)) (list) ( APPEND (fn (LISTLESS (FIRST list) list)) ( APPEND (LISTEQ (FIRST list) list) (fn (LISTGR (FIRST list) list)) ) ) ) )',\n//   // INFLIST : '(λ n . (Y (λ x . (λ f s g . g f s) n x)))',\n//   // REMOVENTH : 'Y (λ fn list n . IF (= n 0) (SECOND list) (IF (NULL list) NIL (CONS (FIRST list) (fn (SECOND list) (- n 1) ) ) ) )',\n//   // NTH : 'Y (λ fn list n . IF (= n 0) (FIRST list) (IF (NULL (list)) NIL (fn (SECOND list) (- n 1)) ) )',\n//   // LEN : 'Y (λ fn list . IF (NULL list) (0) (+ 1 (fn (SECOND list) )) )',\n//   // GETNTH : '(λ end . (Y (λ f n i . (end i) (i) ( (= n 0) (Y (λ f a . (end a) (i) (f) ) ) (f (- n 1)) ) )) )',\n//   // MAP : '(λ fn l . (Y (λ f it . IF (NULL it) (NIL) (CONS (fn (FIRST it)) (f (SECOND it))) )) l )',\n//   // REDUCE : '(λ fn l init . Y (λ f it acc . IF (NULL it) (acc) (f (SECOND it) (fn (FIRST it) acc)) ) l init )',\n//   // APPLY : '(λ f args . Y (λ ff f l . (NULL l) (f) (ff (f (FIRST l)) (SECOND l)) ) f args )',\n//   // RANGE : '(λ m n . Y (λ f e . (= e n) (CONS e NIL) (CONS e (f (+ e 1))) ) m )',\n//   // LISTCOMPR : '(λ args . APPLY (λ op in rng cond . Y (λ f l . (NULL l) (NIL) ( (cond (FIRST l)) (CONS (op (FIRST l)) (f (SECOND l))) (CONS (FIRST l) (f (SECOND l))) ) ) rng ) args )',\n//   // MOD : '(λ n m . (n (λ n . (= n (- m 1)) (0) (+ n 1)) (0)) )',\n//   // INFIX : 'APPLY (λ l op r . op l r)',\n// }\n\n// TODO: remove?\n// export function updateMacros (macroTable : MacroMap) : void {\n//   window.localStorage.setItem('macrotable', JSON.stringify(macroTable))\n// }\n\nexport function reportEvent (category : string, action : string, label : string) : void {\n  try {\n    const tracker = (window as any).ga.getAll()[0]\n    \n    tracker.send('event', category, action, label )\n  }\n  catch (exception) {\n    // TODO: fix?\n    // instead of printing to the console - show notification on the web\n    // console.log(\"\")\n    // console.log('PLEASE DISABLE YOUR ADBLOCKER OR ALLOW GOOGLE ANALYTICS FOR THIS SITE')\n    // console.log(\"\")\n    // console.error(exception)\n  }\n}","import { BoxType } from '../Types'\nimport  { EvaluationStrategy\n        , UntypedLambdaState\n        , UntypedLambdaSettings\n        , UntypedLambdaType\n        , StepRecord\n        , UntypedLambdaExpressionState\n        , SettingsEnabled\n        , PromptPlaceholder\n        , StepMessage\n        , StepValidity } from \"./Types\"\nimport  { ASTReduction\n        , AST\n        , decodeFast as decodeUntypedLambdaFast\n        , Evaluator\n        , NormalEvaluator\n        , None\n        , Expansion\n        , Macro\n        , ASTReductionType\n        , Alpha\n        , Lambda\n        , Beta\n        , Eta\n        , Application\n        , ASTVisitor\n        , Variable\n        , ChurchNumeral\n        , builtinMacros\n        , MacroTable\n        , Token\n        , tokenize\n        , parse\n        , ApplicativeEvaluator\n        , OptimizeEvaluator\n        , NormalAbstractionEvaluator\n        , MacroMap } from '@lambdulus/core'\nimport { Child, Binary } from '@lambdulus/core/dist/ast'\nimport { TreeComparator } from './TreeComparator'\nimport { reportEvent } from '../misc'\n\n\nexport const ADD_BOX_LABEL = '+ Untyped λ Expression'\n\nexport const CODE_NAME = 'UNTYPED_LAMBDA_CALCULUS'\n\nexport const defaultSettings : UntypedLambdaSettings = {\n  type : BoxType.UNTYPED_LAMBDA,\n  SLI : true,\n  expandStandalones : false,\n  strategy : EvaluationStrategy.NORMAL,\n  SDE : true,\n}\n\nexport function createNewUntypedLambdaExpression (defaultSettings : UntypedLambdaSettings) : UntypedLambdaExpressionState {\n  return {\n    ...defaultSettings,\n    __key : Date.now().toString(),\n    type : BoxType.UNTYPED_LAMBDA,\n    subtype : UntypedLambdaType.EMPTY,\n    title : \"Untyped λ Expression\",\n    minimized : false,\n    settingsOpen : true,\n    expression : \"\",\n    ast : null,\n    history : [],\n    isRunning : false,\n    breakpoints : [],\n    timeoutID : undefined,\n    timeout : 5,\n    \n    // strategy : EvaluationStrategy.NORMAL,\n    // singleLetterNames : false,\n    // standalones : false,\n\n    macrolistOpen : false,\n    macrotable : { },\n\n    \n    editor : {\n      placeholder : \"placeholder\",\n      content : \"\",\n      syntaxError : null,\n    }\n  }\n}\n\n// NOTE: Original definition\n// export function toMacroMap (definitions : Array<string>) : MacroMap {\n//   return definitions.reduce((acc : MacroMap, def) => {\n//     const [name, body] = def.split(':=')\n//     return { ...acc, [name.trim()] : body.trim() }\n//   }, {})\n// }\n\nexport function toMacroMap (definitions : Array<string>, SLI : boolean) : MacroMap {\n  /**\n   * This might seem like something really wrong\n   * but hear me out!\n   * if you have SLI enabled and define your macros with SLI in mind - bodies of the macros\n   * contain some SLI syntax -> when expanded in the core - it is parsed with SLI disabled\n   * this might be considered bug of the core\n   * BUT!!! CORE has no way to get the information as of now\n   * I might consider adding another argument to the evaluators - being this specific setting\n   * until then - it's probably realatively safe to first:\n   */\n\n  // get MacroMap with only names - empty definitions\n  const mNames : MacroMap = definitions.reduce((acc : MacroMap, def) => {\n    const [name, body] = def.split(':=')\n\n    if (name.trim().length === 0 || body.trim().length === 0) {\n      throw Error(\"Invalid Macro definition. Possibly empty Macro definition?\")\n    }\n\n    return { ...acc, [name] : '' }\n  }, {})\n  \n  return definitions.reduce((acc : MacroMap, def) => {\n    const [name, body] = def.split(':=')\n\n    // tokenize each body\n    // lexer is given this incomplete macromap with just names\n    // lexer does not need the definitions, it would function well even if it was just an array of the macro names\n    // then parse the body of the macro\n    // once again --> right now - actual macro definitions are not needed because I won't do ANY expansion\n    // not even any real reduction\n    // I just need it to parse and then serialize the body of the macro\n    // that's it!\n    const tokens : Array<Token> = tokenize(body.trim(), { lambdaLetters : ['λ'], singleLetterVars : SLI, macromap : mNames })\n    const ast : AST = parse(tokens, mNames) // macroTable\n\n    return { ...acc, [name.trim()] : ast.toString() }\n  }, {})\n\n  // TODO: please fix it\n  // tokenize shoudl accept Array<MacroName>\n  // each eveluator needs to accept the SLI and possibly other configs? so the CORE\n  // can be absolutely unopionanted about the expansions and stuff\n}\n\nexport function createNewUntypedLambdaBoxFromSource (source : string, defaultSettings : UntypedLambdaSettings, subtype : UntypedLambdaType, macrotable : MacroTable) : UntypedLambdaExpressionState {\n  if (subtype === UntypedLambdaType.EMPTY) {\n    return {\n      ...defaultSettings,\n      __key : Date.now().toString(),\n      type : BoxType.UNTYPED_LAMBDA,\n      subtype,\n      title : \"Untyped λ Expression\",\n      minimized : false,\n      settingsOpen : false,\n      expression : \"\",\n      ast : null,\n      history : [],\n      isRunning : false,\n      breakpoints : [],\n      timeoutID : undefined,\n      timeout : 5,\n      \n      // strategy : EvaluationStrategy.NORMAL,\n      // singleLetterNames : false,\n      // standalones : false,\n  \n      macrolistOpen : false,\n      macrotable, // ...UNTYPED_LAMBDA_INTEGRATION_STATE.macrotable\n  \n      \n      editor : {\n        placeholder : \"placeholder\",\n        content : source,\n        syntaxError : null,\n      }\n    }\n  }\n  else {\n    return createNewUntypedLambdaBoxFromSource2(source, defaultSettings, subtype, macrotable)\n  }\n}\n\nfunction createNewUntypedLambdaBoxFromSource2 (source : string, defaultSettings : UntypedLambdaSettings, subtype : UntypedLambdaType, macrotable : MacroTable) : UntypedLambdaExpressionState {\n  const { SDE, SLI, strategy } = defaultSettings\n\n  const macros : string = Object.entries(macrotable).map(([name, def]) => `${name} := ${def}`).join(';\\n')\n\n  const expression = `${macros}${macros.length ? ';\\n' : ''}${source}`\n  console.log({macros})\n  console.log({expression})\n\n  const macromap : MacroMap = macrotable // toMacroMap(definitions, SLI)\n  \n  try {\n    const tokens : Array<Token> = tokenize(source, { lambdaLetters : ['λ'], singleLetterVars : SLI, macromap })\n    const ast : AST = parse(tokens, macromap) // macroTable\n    \n    \n    let message : StepMessage = { validity : StepValidity.CORRECT, userInput : expression, message : '' }\n    let isNormal = false\n\n    const astCopy : AST = ast.clone()\n\n    const nextReduction = (() => {\n      if (SDE) {\n        return findSimplifiedReduction(astCopy, strategy, macromap)[0]\n      }\n      else {\n        const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n        return evaluator.nextReduction\n      }\n    })()\n\n    \n    if (nextReduction instanceof None) {\n      isNormal = true\n      message.message = 'Expression is in normal form.'\n      \n      reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n    }\n\n    reportEvent('Submit Expression from Link', 'submit valid', source)\n\n\n    return {\n      ...defaultSettings,\n      __key : Date.now().toString(),\n      type : BoxType.UNTYPED_LAMBDA,\n      subtype,\n      title : \"Untyped λ Expression\",\n      minimized : false,\n      settingsOpen : false,\n      isRunning : false,\n      breakpoints : [],\n      timeoutID : undefined,\n      timeout : 5,\n      ast,\n      expression,\n      history : [ {\n        ast : ast.clone(),\n        lastReduction : new None(),\n        step : 0,\n        message,\n        isNormalForm : isNormal,\n        exerciseStep : subtype === UntypedLambdaType.EXERCISE,\n      } ],\n\n      macrolistOpen : false,\n      macrotable : macromap,\n      // macrotable : { ...UNTYPED_LAMBDA_INTEGRATION_STATE.macrotable },\n\n      editor : {\n        content : source,\n        placeholder : PromptPlaceholder.EVAL_MODE,\n        syntaxError : null,\n      }\n    }\n\n  } catch (exception) {\n    reportEvent('Submit Expression from Link', 'submit invalid', source)\n    throw exception\n  }\n}\n\nexport function resetUntypedLambdaBox (state : UntypedLambdaState) : UntypedLambdaState {\n  return {\n    ...state,\n    subtype : UntypedLambdaType.EMPTY,\n    title : \"Untyped λ Expression\",\n    minimized : false,\n    expression : \"\",\n    ast : null,\n    history : [],\n    isRunning : false,\n    breakpoints : [],\n    timeoutID : undefined,\n    timeout : 5,\n    \n    macrolistOpen : false,\n    macrotable : { },\n\n    \n    editor : {\n      placeholder : \"placeholder\",\n      content : \"\",\n      syntaxError : null,\n    }\n  }\n}\n\n// export function createNewUntypedLambdaExercise (defaultSettings : UntypedLambdaSettings) : UntypedLambdaState {\n//   return {\n//     ...defaultSettings,\n//     __key : Date.now().toString(),\n//     type : BoxType.UNTYPED_LAMBDA,\n//     subtype : UntypedLambdaType.EXERCISE,\n//     title : \"Untyped λ Exercise\",\n//     minimized : false,\n//     menuOpen : false,\n//     settingsOpen : false,\n//     expression : \"\",\n//     ast : null,\n//     history : [],\n//     isRunning : false,\n//     breakpoints : [],\n//     timeoutID : undefined,\n//     timeout : 5,\n    \n//     // strategy : EvaluationStrategy.NORMAL,\n//     // singleLetterNames : false,\n//     // standalones : false,\n\n//     macrolistOpen : false,\n//     macrotable : { ...UNTYPED_LAMBDA_INTEGRATION_STATE.macrotable },\n\n    \n//     editor : {\n//       placeholder : \"placeholder\",\n//       content : \"\",\n//       caretPosition : 0,\n//       syntaxError : null,\n//     }\n//   }\n// }\n\n// export function createNewUntypedLambdaMacro (defaultSettings : UntypedLambdaSettings) : UntypedLambdaMacroState {\n//   return (\n//     {\n//       ...defaultSettings,\n//       __key : Date.now().toString(),\n//       type : BoxType.UNTYPED_LAMBDA,\n//       title : \"Untyped λ Macro Expression\",\n//       minimized : false,\n//       menuOpen : false,\n//       settingsOpen : false,\n    \n//       subtype : UntypedLambdaType.MACRO,\n//       expression : '',\n//       ast : null,\n//       macroName : '',\n//       macroExpression : '',\n\n//       macrolistOpen : false,\n//       macrotable : { ...UNTYPED_LAMBDA_INTEGRATION_STATE.macrotable },\n\n      \n//       editor : {\n//         placeholder : PromptPlaceholder.MACRO,\n//         content : '',\n//         caretPosition : 0,\n//         syntaxError : null\n//       }\n//     }\n//   )\n// }\n\n\nexport function decodeUntypedLambdaState (box : UntypedLambdaState) : UntypedLambdaState {\n  return decodeUntypedLambdaExpression(box as UntypedLambdaExpressionState)\n\n  // switch (box.subtype) {\n  //   case UntypedLambdaType.ORDINARY:\n  //     return decodeUntypedLambdaExpression(box as UntypedLambdaExpressionState)\n      \n    // case UntypedLambdaType.MACRO:\n    //   return box //TODO: implement -- it's not really needed\n\n    // case UntypedLambdaType.EXERCISE:\n    //   return decodeUntypedLambdaExpression(box as UntypedLambdaExpressionState)\n  // }\n}\n\nfunction decodeUntypedLambdaExpression (box : UntypedLambdaExpressionState) : UntypedLambdaExpressionState {\n  const untypedLambdaBox : UntypedLambdaExpressionState = box as UntypedLambdaExpressionState\n\n  if (untypedLambdaBox.expression === '') {\n    return untypedLambdaBox\n  }\n  \n  const decodedFirst : AST | null = decodeUntypedLambdaFast(untypedLambdaBox.ast)\n\n  if (decodedFirst === null) {\n    // TODO: repair:\n    // parse expression\n    // replace untypedLambdaBox.ast with parsed AST\n    // for now - throw error\n    throw Error(\"ROOT AST IS NOT DECODABLE\")\n  }\n\n  untypedLambdaBox.ast = decodedFirst\n  untypedLambdaBox.history = untypedLambdaBox.history.map((step : StepRecord, index : number) => {\n    let decodedNth : AST | null = decodeUntypedLambdaFast(step.ast) as AST\n\n    if (decodedNth === null) {\n      // TODO: repair:\n      // try to take previous Step.ast and do the evaluation\n      // though - remember this Step.step (number) may not be + 1 of the previous one\n      // you will need to do the steps as long as need to be\n      // replace decodedNth with parsed AST\n      // for throw\n      throw Error(\"CURRENT STEP IS NOT DECODABLE \" + index)\n    }\n\n    // TODO: maybe instead of this theatre just use the Core . Evalautor\n    // and get real instance of ASTReduction\n    let reduction : ASTReduction | undefined | null = step.lastReduction\n\n    if (step.lastReduction === undefined) {\n      reduction = null\n    }\n\n    return {\n      ...step,\n      lastReduction : reduction,\n      ast : decodedNth, // TODO: as AST this is unsafe\n    }\n  })\n\n  return untypedLambdaBox\n}\n\nexport const GLOBAL_SETTINGS_ENABLER : SettingsEnabled = {\n  SLI : true,\n  expandStandalones : true,\n  strategy : true,\n}\n\n// export const MACRO_SETTINGS_ENABLER : SettingsEnabled = {\n//   SLI : true,\n//   expandStandalones : false,\n//   strategy : false,\n// }\n\ntype PerformEvaluation = (ast : AST) => AST\n\n\nexport function findSimplifiedReduction (ast : AST, strategy : EvaluationStrategy, macrotable : MacroTable) : [ASTReduction, PerformEvaluation] {\n  const evaluator : Evaluator =  new (strategyToEvaluator(strategy) as any)(ast) // new NormalEvaluator(ast) // TODO: get evaluator dipending on the strategy in the future\n  const nextReduction = evaluator.nextReduction\n\n  // nothing to do\n  // TODO: try to contract this whole expression if it's actually known Macro\n  if (evaluator.nextReduction instanceof None) {\n    return [nextReduction, (ast) => ast]\n  }\n\n  if (nextReduction instanceof Expansion && nextReduction.target instanceof ChurchNumeral) {\n    // console.log(\"_________________________________ CHURCH NUMERAL EXPANSION\")\n\n    const newAst = evaluator.perform() // expand Number\n\n    //\n    // ast je cely vyraz - po performu uz modifikovany\n    // newAst je ted to same jako ast\n    // uvnitr celeho stromu hledam dalsi REDEX\n    //\n    const [newreduction] = findSimplifiedReduction(newAst, strategy, macrotable)\n\n    // return [nextReduction, (ast) => newAst]\n\n    if (newreduction instanceof None) {\n      //\n      // newAst nema zadny REDEX\n      // reknu ze se ma provest expanze Churche + vratim funkci, ktera jenom vrati AST ktery je ji poslany\n      // takhle to funguje proto - ze nemuzu naklonovat ast kdyz se findSimplifiedReduction zavola\n      // protoze by pak nesouhlasili identifikatory a podobne --> to vede na to, ze to co mi do findSimplifiedReduction\n      // je poslano - to zmodifikuju a pak proste jenom predpokladam, ze to nikomu nevadi\n      // ukazka naprosto spatnyho designu provadeni redukci a faktu ze AST melo byt immutable\n      //\n\n      // console.log(\"_________________________________ rule I. INSIDE EXPANSION\")\n      return [newreduction, (ast) => ast]\n      // NO REDEX FOUND --> normal form, not expanding Church Numeral\n      // means - I should signal normal form -- perhaps there is a problem\n      // --> previous step should already be normal form\n      // but this way user finds out this is terminal state only after hitting - next step manually -- possible fix?\n    }\n    else {\n      // there's REDEX --> I know for a fact that it's not rule III. (inside the expanded expression)\n      // now - because Church Numerals DON'T have arity - they are supposed to be numbers and not Macros\n      // I can just forgot all the complex ruling and do the sensible thing --> perform \n\n      // console.log(\"_________________________________ CHURCH EXPAND -- INSIDE EXPANSION\")\n      return [nextReduction, (ast) => newAst]\n    }\n  }\n\n  if (nextReduction instanceof Expansion && nextReduction.target instanceof Macro) {\n    // console.log(\"_________________________________ MACRO EXPANSION   \", nextReduction.target.toString())\n    // debugger\n    \n    const { parent, treeSide, target } : Expansion = nextReduction\n    \n    const M : Macro = target.clone()\n\n    {\n      // anchor #1\n      const clone = ast.clone()\n      let newAst = null\n\n      {\n        const evaluator : Evaluator =\n          new (strategyToEvaluator(strategy) as any)(clone) // new NormalEvaluator(ast) // TODO: get evaluator dipending on the strategy in the future\n        newAst = evaluator.perform()\n      }\n\n      const _evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(newAst) // new NormalEvaluator(ast) // TODO: get evaluator dipending on the strategy in the future\n      const nextReduction = _evaluator.nextReduction\n\n      if (nextReduction instanceof Expansion) {\n        return [nextReduction, () => evaluator.perform()]\n      }\n    }\n\n    let newAst = evaluator.perform()\n    // NOTE: if the newreduction is alpha I would like to mutate this variable\n    const expanded = parent !== null && treeSide !== null ? parent[treeSide].clone() : newAst.clone()\n    // const expanded = parent !== null && treeSide !== null ? parent[treeSide] : newAst\n\n    //\n    // newAst je cely vyraz po expanzi soucasneho makra\n    // v nem vyhledam dalsi REDEX\n    //\n    let [newreduction, newperformevaluation] = findSimplifiedReduction(newAst, strategy, macrotable)\n    // NOTE: if the newreduction is alpha I would like to mutate these variables\n    // const newevaluator = new NormalEvaluator(newAst)\n    // const newreduction = newevaluator.nextReduction\n\n    if (newreduction instanceof None) {\n      // console.log(\"_________________________________ rule I. INSIDE EXPANSION\")\n      return [newreduction, (ast) => ast] // (ast) => ast\n      // NO REDEX FOUND --> normal form, not expanding M\n      // means - I should signal normal form -- perhaps there is a problem\n      // --> previous step should already be normal form\n      // but this way user finds out this is terminal state only after hitting - next step manually -- possible fix?\n    }\n\n    if (newreduction instanceof Alpha) {\n      // after the expansion -> next thing is Alpha, that needs to be covered\n      // we can do the alpha and then call findSimplifiedReduction again on that\n      newAst = newperformevaluation(newAst);\n      ([newreduction, newperformevaluation] = findSimplifiedReduction(newAst, strategy, macrotable))\n    }\n\n    // debugger\n    // node : AST = parent === null ? newAst\n    //                                                     (to co jsme expandovali)\n    if (parent !== null && treeSide !== null && findRedexIn(expanded, newreduction)) {\n      // REDEX is completely bounded by expanded M Macro expression\n      // console.log(\"_________________________________ rule III. INSIDE EXPANSION\")\n      return [nextReduction, (_) => evaluator.perform()]\n\n      // REDEX belongs to expanded M\n      // --> expand the macro -- so perform the previous macro expansion\n    }\n\n    const beta : Beta = newreduction as Beta\n    if (parent !== null && treeSide !== null // parent and treeSide won't be null --> parent is either APP or Lambda --> they need to parent the macro which was expanded am I right?\n        && parent instanceof Application\n        && parent[treeSide] instanceof Lambda && beta.redex?.left.identifier === parent[treeSide].identifier\n        && newreduction.type === ASTReductionType.BETA\n        && parent.identifier === beta.redex.identifier) {\n      // console.log(\"_________________________________ rule IV. INSIDE\")\n      // rule IV.\n\n      // if ( ! macroIsSingleStep(M)) {\n      //   return [newreduction, newperformevaluation]\n      // }\n\n\n      const expanded : Lambda = parent[treeSide] as Lambda\n      // const [fnArgNames, fnBody] = splitLambdaFn(expanded)\n      // const fnBody : AST = getFnBody(expanded)\n      const fnArgNames : Array<string> = getFnArgNames(expanded)\n      let arity : number = fnArgNames.length\n      const arit : number | null = getArityOfKnownMacro(M.name())\n      if (arit !== null && arit <= arity) {\n        arity = arit\n      }\n      // const arity : number = getArity(expanded)\n      // console.log(\"arity of the macro is: \", arity)\n      // --> get arity of expression X which was expanded from macro M\n      // it should be simple -- just go to the right for the lambda and as long as it's right side is also lambda count +1\n\n\n      const macroAppRedex : MacroBeta =  extendMacroAppRedex(arity, parent, ast)\n      if (strategy === EvaluationStrategy.APPLICATIVE || hasApplicativeOverride(M)) {\n        // console.log(\"............................. MACRO \" + M.name() + \"   has APPLICATIVE OVERRIDE\")\n\n        for (const app of macroAppRedex.applications) {\n          const [argreduction, argperformevaluation] = findSimplifiedReduction(app.right, strategy, macrotable)\n\n          if (argreduction instanceof None) {\n            continue\n          }\n          else {\n            // debugger\n            // we previously expanded our M in the ast\n            // recursive findSimplifiedReduction then works with that\n            // so current app containes M as expanded Expression\n            // we need to take that back\n            \n            return [argreduction, (ast : AST) => {\n              // const newast : AST = argperformevaluation(ast) // original line\n              app.right = argperformevaluation(app.right)\n\n              parent[treeSide] = M\n              // if (newast.identifier !== app.identifier) {\n              //   app.right = newast\n              //   // this is ugly hack but just checking if it works -- it doesn't\n              // }\n              return ast\n            }]\n          }\n        }\n      }\n\n      // kdyz tohle mam hotove OK\n      // musim se podle strategie rozhodnout co budu delat s tim polem applikaci OK\n      // pokud jsem applicative strategy --> musim jit od zacatku pole applikaci OK\n      // a kontrolovat ze app.right je v normalnim tvaru OK\n      // pokud nektery z nich neni - tak jednoduse vezmu ten right -> reknu najdi mi redex a to je to co odsud vratim OK\n      // stejne tak, pokud ma macro applicative override a nektery argument by nebyl normalni tvar OK\n      // jinak pokracuju dal OK\n\n      // return macrobeta reduction as a reduction OK\n      // which is essentially just array of applications OK\n      // also the TOP context needs to check the arity - not just me OK\n      // the performer is just some foreach on the array of betas OK\n\n      \n      // let fnBody : AST = expanded.right\n      // let fn : AST = expanded\n      // const getFnBody = () => (fn as Lambda).right\n      // const setFn = (tree : AST) => fn = tree\n      return [macroAppRedex, (ast) => {\n        // debugger\n        // about SINGLE-STEP:\n        // this function needs to perform all the normalisation if single-step is True\n        // for that reason - I need to remember the last parent of the Extended-REDEX\n        // if that last parent is null --> then it's actually the whole ast\n        // THEN --> after the for loop I need to run another for loop which runs until the last parent is reduced to the normal form\n        // it it's the whole tree/ast --> then it's easier\n        // if it's some sub-tree than it's either APP or ABS\n        // if it's Lambda -> kinda easy --> I can pick this Lambda and normalize it's right side -> then set the result to the original Lambda\n        // it it's APP -> probably same - just need to decide/remember the treeside\n        // for that reason - it would be best to remember also the last app\n        // let's do this now\n        let lastapp : AST | null = null\n        let lastparent : Binary | null = null\n\n        // debugger\n        \n        // budu muset projit kazdou aplikaci v poli\n        // vytvorit pro ni beta redukci pro vyraz ktery vznikl v predchozi iteraci - proto nejde udelat pole beta redukci dopredu\n        // a provest je - na konci vratim vysledny AST\n        for (const app of macroAppRedex.applications) {\n          let appParent : Binary | undefined | null = macroAppRedex.parents.shift() as Binary\n          let treeSide : Child | null = appParent === undefined ? null : appParent.left.identifier === app.identifier ? Child.Left : Child.Right\n          \n          \n\n          \n\n          const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(app) // new NormalEvaluator(app)\n          evaluator.reducer.perform()\n          const reduced : AST = evaluator.reducer.tree\n\n          if (appParent === undefined || treeSide === null) {\n            appParent = null\n            treeSide = null\n            ast = reduced\n            lastapp = ast\n          }\n          else {\n            appParent[treeSide] = reduced\n            lastapp = appParent[treeSide] // what about if the last parent is null?\n            // that means lastapp is going to be something old and wrong right?\n            // maybe it should be ast/reduced\n\n          }\n\n          lastparent = appParent // because I am lazy and don't want to use ifs before the for loop\n\n\n          // let appParent : Binary | undefined | null = macroAppRedex.parents.shift() as Binary\n          // let treeSide : Child | null = appParent === undefined ? null : appParent.left.identifier === app.identifier ? Child.Left : Child.Right\n          \n          // if (appParent === undefined) {\n          //   appParent = null\n          //   treeSide = null\n          // }\n\n          // lastparent = appParent // because I am lazy and don't want to use ifs before the for loop\n          \n          // const argName : string = fnArgNames.shift() as string\n\n          // // if ((app.left as Binary).right === undefined) {\n          // //   debugger\n          // // }\n\n          // const beta : Beta = new Beta(app, appParent as Binary, treeSide, (app.left as Lambda).body , argName, app.right) // getFnBody()\n\n          // // fnBody = (fnBody as Application).right\n          // // setFn(getFnBody())\n\n          // const reducer : BetaReducer = new BetaReducer(beta, ast)\n          // reducer.perform()\n          // ast = reducer.tree\n        }\n\n        if (macroIsSingleStep(M)) {\n          if (lastapp === null) {\n            throw Error(\"This is bad, real bad.\")\n            // NOTE LATER: not sure what does that mean?\n          }\n  \n          if (lastparent === null) {\n            // normalize the whole tree\n            // top-most APP or ABS a result of the Macro-Beta\n  \n            while (true) {\n              const [nextReduction, evaluateReduction] : [ASTReduction, any] =\n                findSimplifiedReduction(ast, strategy, macrotable)\n              \n              if (nextReduction instanceof None) {\n                return tryMacroContraction(ast, macrotable)\n              }\n              else {\n                ast = evaluateReduction(ast)\n              }\n            }\n          }\n          else {\n            const treeSide : Child = lastparent.left.identifier === lastapp.identifier ? Child.Left : Child.Right\n  \n            // debugger\n            while (true) {\n              const [nextReduction, evaluateReduction] : [ASTReduction, any] =\n                findSimplifiedReduction(lastapp as AST, strategy, macrotable)\n  \n              if (nextReduction instanceof None) {\n                lastparent[treeSide] = tryMacroContraction(lastapp as AST, macrotable)\n                return ast\n              }\n              else {\n                lastapp = evaluateReduction(lastapp)\n              }\n            }\n          }\n        }\n        \n        return ast // it it's not single-step Macro --> then no contraction I guess\n      }]\n    }\n\n    // THIS IS WRONG --> IT'S NOT NEEDED -- INSTEAD I FIXED RULE III AND IT SHOULD BE ENOUGH\n    // if (newreduction instanceof Expansion) {\n    //   console.log(\"_________________________________ rule V. INSIDE EXPANSION\")\n    //   // Expansion inside Expansion\n    //   // this is for cases --> when one macro needs to expanded because what it expands to is expression ->\n    //   // which leads to another expansion --> because there is some Macro M2 which contains redex for example\n    //   // which means - I need to actually expand \n    //   return [nextReduction, (_) => newAst]\n    // }\n\n    // if (parent !== null && treeSide !== null && ( ! findRedexIn(parent[treeSide], newreduction)))\n    // this is fallbacking action\n    // redex was found - but does not concern previously expanded macro - so the expansions is unnecessary\n    // eslint-disable-next-line\n    {\n      // console.log(\"_________________________________ rule II. INSIDE THIS IS FALLBACK\")\n      // console.log(newreduction.type)\n\n      // REDEX is NOT inside expanded M -- NOT rule III.\n      // expanded Macro is also not part of the REDEX -- NOT rule IV\n      // --> not expanding M just perform the second reduction but on original tree\n      return [newreduction, (ast) => {\n        const resAST = newperformevaluation(newAst)\n        const p = parent as AST\n        const ts = treeSide as String\n\n        // if (p === null || ts === null) {\n        //   console.log(nextReduction)\n        //   console.log(newreduction)\n        //   console.log()\n        //   debugger\n        // }\n\n        if (p !== null && ts !== null) {\n          (p as any)[ts as any] = M\n        }\n\n        // // parent should be not-null\n        // // because if there was a Macro which we were able to Expand\n        // // and then there has been found Redex which is not part of the newly expanded sub-tree\n        // // the new Redex simply has to be in different part of the tree --> which means - M (original Macro) is not the root\n        // //\n        // // this is aparenlty not true\n        // // A := + 1 2; B := A; B\n        // // probably because there are two levels of macro expansion and this leads to parent possibly being null\n        // // after the last change -- anchor #1\n        // // this should once again be true - but just to be sure - I will leave it inside the if\n\n        return resAST\n      }]\n    }\n  }\n  else {\n    // console.log(\"_________________________________ just normal stuff\")\n    return [nextReduction, (ast) => evaluator.perform()]\n\n  // {\n  //   const astCopy : AST = ast.clone()\n  //   const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n    \n  //   if (evaluator.nextReduction instanceof None) {\n  //     isNormal = true\n  //     message = 'Expression is in normal form.'\n      \n  //     reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n  //   }\n\n  //   setBoxState({\n  //     ...state,\n  //     history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal } ],\n\n  //   })\n  // }\n  }\n}\n\nexport function tryMacroContraction (ast : AST, macrotable : MacroTable) : AST {\n  // compare the ast with all the bulti-in macros\n  // compare the ast with all the user-defined macros\n\n  if (isChurchNumeral(ast)) {\n    const n : number = churchNumeralToNumber(ast as Lambda)\n    const [s, z] : [string, string] = churchArgNames(ast)\n\n    if (n === 0 && s === 's' && z === 'z') {\n      return parse(tokenize(`0`, { lambdaLetters : ['λ'], singleLetterVars : false, macromap : macrotable }), macrotable)\n    }\n    else if (n === 0 && s === 't' && z === 'f') {\n      return parse(tokenize(`F`, { lambdaLetters : ['λ'], singleLetterVars : false, macromap : macrotable }), macrotable)\n    }\n\n    return parse(tokenize(`${n}`, { lambdaLetters : ['λ'], singleLetterVars : false, macromap : macrotable }), macrotable)\n  }\n  \n  for (const [name, definition] of [ ...Object.entries(builtinMacros), ...Object.entries(macrotable) ]) {\n    // parse the definition\n    const tokens : Array<Token> = tokenize(definition, { lambdaLetters : ['λ'], singleLetterVars : false, macromap : macrotable })\n    const macroast : AST = parse(tokens, macrotable)\n\n    const comparator : TreeComparator = new TreeComparator([ast, macroast], [macrotable, macrotable])\n\n    if (comparator.equals) {\n      const macroNameAst : AST = parse(tokenize(name, { lambdaLetters : ['λ'], singleLetterVars : false, macromap : macrotable }), macrotable)\n\n\n      // const virtualToken : Token = new Token((macroNameAst as Macro).token.type, name, BLANK_POSITION)\n      return macroNameAst // this is dirty-fix -- because the following line somehow produces macro which\n      // expand incorrectly to `undefined` value\n      // return new Macro(virtualToken, macrotable)\n    }\n  }\n\n  return ast\n\n  // for (const macro : )\n}\n\nfunction isChurchNumeral (ast : AST) : boolean {\n  if ( ! (ast instanceof Lambda)) {\n    return false\n  }\n\n  if ( ! (ast.body instanceof Lambda)) {\n    return false\n  }\n\n  return isPeanoNumber(ast.argument.name(), ast.body.argument.name(), ast.body.body)\n}\n\nfunction churchArgNames (ast : AST) : [string, string] {\n  return [(ast as Lambda).argument.name(), ((ast as Lambda).body as Lambda).argument.name()]\n}\n\nfunction isPeanoNumber (s : string, z : string, ast : AST) : boolean {\n  if (ast instanceof Variable && ast.name() === z) {\n    return true\n  }\n\n  if (ast instanceof Application && ast.left.toString() === s) {\n    return isPeanoNumber(s, z, ast.right)\n  }\n\n  return false\n}\n\nfunction churchNumeralToNumber (ast : Lambda) : number {\n  const s : string = ast.argument.name()\n  const z : string = (ast.body as Lambda).argument.name()\n\n  return peanoToNumber((ast.body as Lambda).body, s, z)\n}\n\nfunction peanoToNumber (ast : AST, s : string, z : string) : number {\n  if (ast instanceof Variable && ast.name() === z) {\n    return 0\n  }\n  else {\n    return 1 + peanoToNumber((ast as Application).right, s, z)\n  }\n}\n\n\nfunction getArityOfKnownMacro (macroname : string) : number | null {\n  if ([ \"*\", \"+\", \"/\", \"-\", \"^\", \"DELTA\", \"=\", \">\", \"<\", \">=\", \"<=\", \"AND\", \"OR\" ].includes(macroname)) {\n    return 2\n  }\n\n  if ([ \"ZERO\", \"NOT\", \"SUC\", \"PRED\" ].includes(macroname)) {\n    return 1\n  }\n\n  return null\n}\n\n/**\n * Decides if the result of the application of the macro M to its arguments should evaluate to the normal form\n */\nfunction macroIsSingleStep (macro : Macro) : boolean {\n  if ([ \"*\", \"+\", \"/\", \"-\", \"^\", \"DELTA\", \"=\", \">\", \"<\", \">=\", \"<=\", \"ZERO\", \"NOT\", \"AND\", \"OR\", \"PRED\", \"SUC\" ].includes(macro.name())) {\n    return true\n  }\n\n  // \"T\", \"F\" -- functioning as `if then else` --> therefore can not be Single-Step\n\n  return false\n}\n\n\n// this is basic implementation\n// perhaps Visitor pattern would be better\nfunction findRedexIn (tree : AST, reduction : ASTReduction) : boolean {\n  if (reduction.type === ASTReductionType.ALPHA) {\n    // somehow solve this mess\n    const alpha : Alpha = reduction as Alpha\n\n    if (Array.from(alpha.conversions).some((lambda : Lambda) => tree.identifier === lambda.identifier)) {\n      return true\n    }\n  }\n  else if (reduction.type === ASTReductionType.BETA) {\n    const beta : Beta = reduction as Beta\n    if (beta.treeSide !== null && beta.parent !== null && tree.identifier === beta.parent[beta.treeSide].identifier) {\n      return true\n    }\n  }\n  else if (reduction.type === ASTReductionType.ETA) {\n    const eta : Eta = reduction as Eta\n    if (tree.identifier === eta.parent?.identifier) {\n      return true\n    }\n  }\n  else if (reduction.type === ASTReductionType.EXPANSION) {\n    // debugger\n    const expansion : Expansion = reduction as Expansion\n    if (tree.identifier === expansion.target.identifier) {\n      return true\n    }\n  }\n  else if (reduction.type === ASTReductionType.GAMA) {\n    const macrobeta : MacroBeta = reduction as MacroBeta\n    if (tree.identifier === macrobeta.applications[macrobeta.applications.length - 1].identifier) {\n      return true\n    }\n  }\n\n  if (tree instanceof Application || tree instanceof Lambda) {\n    return findRedexIn(tree.left, reduction) || findRedexIn(tree.right, reduction)\n  }\n  else {\n    return false\n  }\n}\n\n// function getArity (ast : AST) : number { \n//   if (ast instanceof Lambda) {\n//     return 1 + getArity(ast.right)\n//   }\n//   else {\n//     return 0\n//   }\n// }\n\n// function splitLambdaFn (ast : AST) : [Array<string>, AST] {\n//   if (ast instanceof Lambda) {\n//     const [args, body] = splitLambdaFn(ast.right)\n//     return [[ast.left.name(), ...args], body]\n//   }\n//   else {\n//     return [[], ast]\n//   }\n// }\n\nfunction getFnArgNames (ast : AST) : Array<string> {\n  if (ast instanceof Lambda) {\n    return [ast.left.name(), ...getFnArgNames(ast.right)]\n  }\n  else {\n    return []\n  }\n}\n\n\nfunction extendMacroAppRedex (arity : number, basepoint : Application, tree : AST) : MacroBeta {\n  const extender : NormalMacroRedexExtender = new NormalMacroRedexExtender(arity, basepoint, tree)\n\n  return new MacroBeta(extender.applications, extender.parents, arity)\n}\n\nexport class MacroBeta implements ASTReduction {\n  public type : ASTReductionType = ASTReductionType.GAMA\n  constructor (public applications : Array<Application>, public parents : Array<AST>, public arity : number) {}\n}\n\nexport class NormalMacroRedexExtender extends ASTVisitor {\n  public parents : Array<AST> = []  \n  public applications : Array<Application> = []\n\n  private found : boolean = false\n\n  constructor (private arity : number, private basepoint : AST, tree : AST) {\n    super()\n\n    tree.visit(this)\n  }\n\n  onApplication(application : Application): void {\n    if (application.identifier === this.basepoint.identifier) {\n      this.applications.push(application)\n      this.found = true\n      return\n    }\n\n    // go to the left\n    // if found there - I might need to append this application to the list\n    // depending on: is arity bigger than length of list? && is last application in the list the one on the left?\n    // then return\n    application.left.visit(this)\n    if (this.found &&\n      application.left.identifier === this.applications[this.applications.length - 1].identifier) {\n        if (this.arity > this.applications.length) {\n          this.applications.push(application)\n        }\n\n        this.parents.push(application) // pushing this APP as a parent of the previously last one in the list\n        return\n    }\n\n    if (this.found) {\n      return\n    }\n\n    // go to the right\n    // cause it's on the right -> it means this application is definitely not going to the list\n    // so just try to find it there and return\n    application.right.visit(this)\n    if (this.found &&\n      application.right.identifier === this.applications[this.applications.length - 1].identifier) {\n        this.parents.push(application)\n      }\n    return\n  }\n\n  onLambda(lambda : Lambda): void {\n    // lambda definitely interrupts the sequence of APPs\n    // so go find the stuff in the right\n    // but that's all you can do\n    lambda.right.visit(this)\n    if (this.found &&\n      lambda.right.identifier === this.applications[this.applications.length - 1].identifier) {\n        this.parents.push(lambda)\n      }\n    return\n  }\n\n  onChurchNumeral(ChurchNumeral : ChurchNumeral): void {\n    return\n  }\n\n  onMacro(macro : Macro): void {\n    return\n  }\n\n  onVariable(variable : Variable): void {\n    return\n  }\n}\n\nfunction hasApplicativeOverride (macro : Macro) : boolean {\n  // TODO: implement later\n  return [\"*\", \"+\", \"/\", \"-\", \"^\", \"DELTA\", \"=\", \">\", \"<\", \">=\", \"<=\", \"ZERO\", \"NOT\", \"PRED\", \"SUC\"].includes(macro.name())\n  \n  //  \"T\", \"F\"\n  // \"AND\", \"OR\"\n  // return false\n}\n\nexport function strategyToEvaluator (strategy : EvaluationStrategy) : Evaluator {\n  switch (strategy) {\n    case EvaluationStrategy.NORMAL:\n      return NormalEvaluator as any\n \n    case EvaluationStrategy.APPLICATIVE:\n      return ApplicativeEvaluator as any\n\n    case EvaluationStrategy.OPTIMISATION:\n      return OptimizeEvaluator as any\n\n    case EvaluationStrategy.ABSTRACTION: // this will be removed\n      return NormalAbstractionEvaluator as any // this will be removed\n  }\n}","import { CODE_NAME as UNTYPED_CODE_NAME, decodeUntypedLambdaState } from './untyped-lambda-integration/AppTypes'\nimport { defaultSettings as UntypedLambdaDefaultSettings } from './untyped-lambda-integration/AppTypes'\n\nimport { BoxType, Screen, AppState, GlobalSettings, NotebookState, BoxState } from \"./Types\"\nimport { UntypedLambdaState } from './untyped-lambda-integration/Types'\n\n\nexport const CLEAR_WORKSPACE_CONFIRMATION : string =\n`This will delete this whole Notebook from your browser's memory.\n\n                                          Are you sure?`\n\n\nexport function mapBoxTypeToStr (type : BoxType) : string {\n  switch (type) {\n    case BoxType.UNTYPED_LAMBDA:\n      return 'untypedLambdaBox'\n\n    case BoxType.MARKDOWN:\n      return 'markDownBox'\n    default:\n      return ''\n  }\n}\n\nexport const InitNotebookState : NotebookState = {\n  boxList : [],\n  activeBoxIndex : NaN,\n  focusedBoxIndex : undefined,\n  settings : { [UNTYPED_CODE_NAME] : UntypedLambdaDefaultSettings, },\n\n  locked : false,\n  menuOpen : false,\n\n  __key : Date.now().toString(),\n  name : \"Default Ntbk\",\n  editingName : false,\n  persistent : true,\n}\n\nexport const EmptyAppState : AppState = {\n  notebookList : [ InitNotebookState ],\n  currentNotebook : 0,\n  currentScreen : Screen.MAIN,\n  darkmode : false\n}\n\n\nexport function updateSettingsInStorage (settings : GlobalSettings) : void {\n  window.localStorage.setItem('global-settings', JSON.stringify(settings))\n}\n\nexport function loadSettingsFromStorage () : GlobalSettings {\n  const defaultSettings = {\n    [UNTYPED_CODE_NAME] : {}\n  }\n\n  const serialized : string | null = window.localStorage.getItem('global-settings')\n  const deserialized : GlobalSettings =  serialized === null ? defaultSettings : JSON.parse(serialized)\n\n  \n  for (const [key, value] of Object.entries(deserialized)) {\n    switch (key) {\n      case UNTYPED_CODE_NAME:\n        deserialized[key] = { ...UntypedLambdaDefaultSettings, ...value }\n        break;\n    \n      default:\n        console.error(\"Settings CODE NAME is not one of known Code Names.\")\n        break;\n    }\n  }\n\n  return deserialized\n}\n\n\nexport function loadAppStateFromStorage () : AppState {\n  const maybeState : string | null = localStorage.getItem('AppState')\n\n  if (maybeState === null) {\n    localStorage.setItem('AppState', JSON.stringify(EmptyAppState))\n    return EmptyAppState\n  }\n  else {\n    try {\n      return decode(JSON.parse(maybeState))\n    }\n    catch (e) {\n      console.error(`Error while loading app state from the storage.\\n\\n${e}`)\n\n      return EmptyAppState\n    }\n  }\n}\n\nexport function updateAppStateToStorage (state : AppState) : void {\n  localStorage.setItem('AppState', JSON.stringify(state))\n}\n\nexport function updateNotebookStateToStorage (notebook : NotebookState, index : number) {\n  if ( ! notebook.persistent) {\n    return\n  }\n\n  const state : AppState = loadAppStateFromStorage()\n\n  state.notebookList[index] = notebook\n\n  updateAppStateToStorage(state)\n}\n\n// TODO: This function is going to be replaced with correct implementation of decoding\n// this slowly becomes better and better base for the final implementation\n/**\n * This function THROWS Error in case of invalid argument\n * @param state : Deserialized form of AppState\n */\nexport function decode (state : AppState) : AppState | never {\n  const notebookList : Array<NotebookState> = state.notebookList.map(decodeNotebook)\n  \n  return {\n    ...state,\n    notebookList,\n  }\n}\n\nexport function decodeNotebook (notebook : NotebookState) : NotebookState | never {\n  const boxList : Array<BoxState> = notebook.boxList.map((box : BoxState, index : number, arr : Array<BoxState>) => {\n    switch (box.type) {\n      case BoxType.UNTYPED_LAMBDA: {\n        return decodeUntypedLambdaState(box as UntypedLambdaState)\n      }\n\n      //TODO: implement for other Box Types\n    \n      default:\n        return box\n    }\n  })\n\n  return {\n    ...notebook,\n    boxList,\n  }\n}\n","import React, { ChangeEvent } from 'react'\n\nimport { AppState, Screen, NotebookState } from '../Types'\n\nimport '../styles/TopBar.css'\nimport { decodeNotebook } from '../Constants'\n\n\ninterface Props {\n  state : AppState\n  onImport (notebook : NotebookState) : void\n  onClearWorkspace () : void\n  onScreenChange (screen : Screen) : void\n  onDarkModeChange () : void\n}\n\nexport default function TopBar (props : Props) : JSX.Element {\n  const { state, onImport, onClearWorkspace, onScreenChange, onDarkModeChange } : Props = props\n  const { currentNotebook, notebookList, currentScreen, darkmode } : AppState = state\n  const ntbk : NotebookState = notebookList[currentNotebook]\n\n  const { name } : NotebookState = ntbk\n\n  // const dehydrated : object = dehydrate(state)\n\n  const serialized : string = JSON.stringify(ntbk)\n  const link : string = createURL(serialized)\n\n  return (\n    <div className='top-bar'>\n      <div className='cursor-pointer top-bar--notebook-name-container' onClick={ () => onScreenChange(Screen.MAIN) } >\n        <span className='top-bar--notebook-name'>\n          { name }\n        </span>\n      </div>\n\n      <span className='top-bar--item-container'>\n\n        {/* SETTINGS */}\n        <span\n          className={ currentScreen === Screen.SETTINGS ? 'top-bar--item top-bar--item-hoverable top-bar--item-hoverable--active' : 'top-bar--item top-bar--item-hoverable' }\n          title='Go to the Settings'\n          onClick={ () => {\n            if (currentScreen === Screen.SETTINGS) {\n              onScreenChange(Screen.MAIN)\n            }\n            else {\n              onScreenChange(Screen.SETTINGS)\n            }\n          } }\n        >\n          <i\n            className=\"top-icon fas fa-cogs\"\n          />\n          <p className='top-bar--icon-label'>Settings</p>\n        </span>\n\n        {/* Clear the Whole Workspace */}\n        <span\n          className='top-bar--item top-bar--item-hoverable'\n          title='Clear the Whole Workspace'\n          onClick={ onClearWorkspace }\n        >\n          <i\n            className=\"top-icon fas fa-eraser\"\n          />\n          <p className='top-bar--icon-label'>Clear All</p>\n        </span>\n \n        {/* Export Notebook */}\n        \n        <a\n          className='export'\n          href={ link }\n          download=\"notebook_lambdulus.lus\" // TODO: change the name according to the notebook name\n          onClick={ () => setTimeout(() => {\n            // window.URL.revokeObjectURL(link)\n            // TODO: I shouldn't NOT do this - but if I revoke I can't click it again without re-render\n\n            // reportEvent('Export notebook', `Notebook: ${serialized}`, '') // TODO: report event\n          }, 10) }\n        >\n          <span\n            className='top-bar--item top-bar--item-hoverable'\n            title='Download this Notebook'\n          >\n            <i id='download' className=\"top-icon fas fa-cloud-download-alt\" />\n          \n          <p className='top-bar--icon-label'>Export</p>\n          </span>\n        </a>\n \n        {/* Import Notebook */}\n        <input type=\"file\" accept=\".lus\" id=\"input\"\n          onChange={ (e) => onFiles(e, onImport) }\n        />\n          <label htmlFor=\"input\">\n            <span\n              className='top-bar--item top-bar--item-hoverable'\n              title='Import a Notebook from Computer'\n            >\n              <i className=\"top-icon fas fa-cloud-upload-alt\" />\n              <p className='top-bar--icon-label'>Import</p>\n            </span>\n          </label>\n\n        {/* DARKMODE */}\n        <span\n          className='top-bar--item top-bar--item-hoverable'\n          title='Toggle the theme.'\n          onClick={ onDarkModeChange }\n        >\n          <i\n            className= { darkmode ? \"top-icon fas fa-solid fa-sun\" : \"top-icon fas fa-solid fa-moon\" }\n          />\n          <p className='top-bar--icon-label'>{ darkmode ? 'Light Mode' : 'Dark Mode' }</p>\n        </span>\n\n       </span>\n    </div>\n  )\n}\n\nfunction onFiles (event : ChangeEvent<HTMLInputElement>, onImport : (notebook : NotebookState) => void) : void {\n  const { target : { files } } = event\n  if (files === null) {\n    return\n  }\n\n  const file : File = files[0]\n  const reader : FileReader = new FileReader()\n  reader.onload = (event : Event) => {\n    const notebook : NotebookState = JSON.parse(reader.result as string)\n\n    onImport(decodeNotebook(notebook))\n\n    // onImport(hydrate(state))\n    // reportEvent('Import notebook', `Notebook named ${ file.name }`, '')\n  }\n\n  reader.readAsText(file) \n}\n\nfunction createURL (content : string) : string {\n  const data = new Blob([ content ], {\n    type: 'application/json'\n  })\n\n  return window.URL.createObjectURL(data);\n}","import React from 'react'\n\nimport { Screen, AppState } from '../Types'\n\n\nimport '../styles/MenuBar.css'\n// import { reportEvent } from '../misc'; // later\n\ninterface MenuBarProperties {\n  state : AppState\n  // onImport (state : AppState) : void\n  // onClearWorkspace () : void\n  onScreenChange (screen : Screen) : void\n}\n\nexport default function MenuBar (props : MenuBarProperties) : JSX.Element {\n  const { state, onScreenChange } : MenuBarProperties = props\n\n  const { currentScreen } = state\n\n  return (\n    <div id=\"menu-bar\">\n      <div\n        className='tab'\n        title='Get Info about this Tool'\n        onClick={ () => onScreenChange(Screen.MAIN) }\n      >\n        <span className='lambdulusIcon'>λ</span>\n        <p className='iconLabel'>Lambdulus</p>\n      </div>\n\n      {/* <div className='separator' /> */}\n\n      {/* NOTEBOOK */}\n      {/* <div\n        className={ currentScreen === Screen.NOTEBOOKS ? 'currentTab tab tab-hoverable' : 'tab tab-hoverable' }\n        title='Show All Notebooks'\n        onClick={ () => onScreenChange(Screen.NOTEBOOKS) }\n      >\n        <i\n          // className=\"icon far fa-file-alt\"\n          className=\"icon far fa-copy\"\n        />\n        <p className='iconLabel'>Notebooks</p>\n      </div> */}\n\n      <div className='menu-bar--bottom-part'>\n        {/* Issues */}\n        <div\n          className='tab tab-hoverable'\n          title='Submit a Bug or a Feature Request'\n        >\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href='https://github.com/lambdulus/frontend/issues'\n          >\n            <i className=\"icon fas fa-bug\" />\n          </a>\n          <p className='iconLabel'>GH Issues</p>\n        </div>\n\n        {/* MANUAL/HELP */}\n        <div\n          className={ currentScreen === Screen.HELP ? 'currentTab tab tab-hoverable' : 'tab tab-hoverable' }\n          title={ currentScreen === Screen.MAIN ? 'Show the Manual' : 'Go back' }\n          onClick={ () => {\n            if (currentScreen === Screen.HELP) {\n              onScreenChange(Screen.MAIN)\n            }\n            else {\n              onScreenChange(Screen.HELP)\n            }\n          }}\n        >\n          <i\n            className=\"icon far fa-question-circle\"\n          />\n          <p className='iconLabel'>Manual</p>\n        </div>\n      </div>\n\n\n    </div>\n  )\n}\n\n// function dehydrateBox (box : BoxState) : BoxState {\n//   const { type } : BoxState = box\n\n//   if (type === BoxType.EXPRESSION) {\n\n//     return {\n//       ...box,\n//       ast : null as any, // TODO: don't\n//       history : [], // TODO: don't\n//       isRunning : false,\n//       breakpoints : [], // TODO: solve how to don't\n//       timeoutID : undefined,\n//     }\n//   }\n\n//   return box\n// }\n\n// function dehydrate (state : AppState) : AppState {\n//   return {\n//     ...state,\n//     submittedBoxes : state.submittedBoxes.map(dehydrateBox)\n//   }\n// }\n\n// function hydrateBox (box : BoxState, macroTable : MacroMap) : BoxState {\n//   const { type } : BoxState = box\n  \n//   if (type === BoxType.EXPRESSION) {\n//     const { singleLetterNames } = box as UntypedLambdaState\n//     const ast : AST = parseExpression((box as UntypedLambdaState).expression, { macroTable, singleLetterNames })\n\n//     return {\n//       ...box,\n//       ast,\n//       history : [ { ast, lastReduction : None, step : 0, message : '', isNormalForm : false } ],\n//     }\n//   }\n\n//   return box\n// }\n\n// function hydrate (dehydrated : AppState) : AppState {\n//   const { macroTable } = dehydrated\n//   const config = { macroTable }\n\n//   return {\n//     ...dehydrated,\n//     submittedBoxes : dehydrated.submittedBoxes.map((box) => hydrateBox(box, macroTable))\n//   }\n// }\n\n// interface Config {\n//   singleLetterNames : boolean\n//   macroTable : MacroMap\n// }\n\n// function parseExpression (expression : string, config : Config) : AST {\n//   const { singleLetterNames : singleLetterVars, macroTable } : Config = config\n  \n//   const tokens : Array<Token> = tokenize(expression, { lambdaLetters : ['λ'], singleLetterVars })\n//   const ast : AST = parse(tokens, macroTable)\n\n//   return ast\n// }\n\n\n// function onFiles (event : ChangeEvent<HTMLInputElement>, onImport : (notebook : NotebookState) => void) : void {\n//   const { target : { files } } = event\n//   if (files === null) {\n//     return\n//   }\n\n//   const file : File = files[0]\n//   const reader : FileReader = new FileReader\n//   reader.onload = (event : Event) => {\n//     const notebook : NotebookState = JSON.parse(reader.result as string)\n\n//     onImport(decodeNotebook(notebook))\n\n//     // onImport(hydrate(state))\n//     // reportEvent('Import notebook', `Notebook named ${ file.name }`, '')\n//   }\n\n//   reader.readAsText(file) \n// }\n\n// function createURL (content : string) : string {\n//   const data = new Blob([ content ], {\n//     type: 'application/json'\n//   })\n\n//   return window.URL.createObjectURL(data);\n// }","import { BoxType, AbstractBoxState } from \"../Types\"\n\n\nexport interface NoteState extends AbstractBoxState {\n  __key : string\n  type : BoxType\n  note : string\n  isEditing : boolean\n  editor : {\n    placeholder : string\n    content : string\n    caretPosition : number\n    syntaxError : Error | null\n  }\n}\n\nexport function createNewMarkdown () : NoteState {\n  return {\n    __key : Date.now().toString(),\n    type : BoxType.MARKDOWN,\n    title : 'Markdown Box',\n    minimized : false,\n    settingsOpen : false,\n    note : '',\n    isEditing : true,\n    editor : {\n      placeholder : PromptPlaceholder,\n      content : '',\n      caretPosition : 0,\n      syntaxError : null\n    }\n  }\n}\n\nexport function resetMarkdownBox (state : NoteState) : NoteState {\n  return {\n    ...state,\n    minimized : false,\n    note : '',\n    isEditing : true,\n    editor : {\n      placeholder : PromptPlaceholder,\n      content : '',\n      caretPosition : 0,\n      syntaxError : null\n    }\n  }\n}\n\nexport const PromptPlaceholder : string = 'Note in MarkDown'\n\nexport function onMarkDownBlur (state : NoteState) : NoteState {\n  return {\n    ...state,\n    isEditing: false,\n  }\n}\n\nexport function onMarkDownActive (state : NoteState) : NoteState {\n  return {\n    ...state,\n    isEditing : true,\n  }\n}","import React from 'react'\nimport { GlobalSettings, BoxState } from '../Types'\nimport { createNewMarkdown } from '../markdown-integration/AppTypes'\nimport { UntypedLambdaSettings, UntypedLambdaState } from '../untyped-lambda-integration/Types'\nimport { createNewUntypedLambdaExpression, ADD_BOX_LABEL, CODE_NAME as UNTYPED_CODE_NAME } from '../untyped-lambda-integration/AppTypes'\n\n\nimport '../styles/PickBoxTypeModal.css'\n\n\ninterface Props {\n  addNew (box : BoxState) : void\n  settings : GlobalSettings\n}\n\n\nexport default function PickBoxTypeModal (props : Props) : JSX.Element {\n  const { addNew, settings } : Props = props\n\n  const untLSettings : UntypedLambdaSettings = settings[UNTYPED_CODE_NAME] as UntypedLambdaState\n\n  const addLambdaBox = (\n    <div className='add-box--group'\n      onClick={ (e) => {\n        e.stopPropagation()\n        // this.setState({ opened : false })\n        addNew(createNewUntypedLambdaExpression(untLSettings)) }\n      }\n    >\n      <div\n        className='plusBtn'\n        title='Create new λ box'\n      >\n        <p className='create-box--big'>λ</p>\n        <p className='creat-box--label'>{ ADD_BOX_LABEL }</p>\n      </div>\n    </div>\n  )\n\n  // const addLispBox = (\n  //   <div className='add-box--group'\n  //     onClick={ (e) => {\n  //       e.stopPropagation()\n  //       // this.setState({ opened : false })\n  //       addNew({__key : Date.now().toString()} as BoxState) } // NOTE: just for now\n  //     }\n  //   >\n  //     <div\n  //       className='plusBtn'\n  //       title='Create new Lisp box'\n  //     >\n  //       <p className='create-box--big'>()</p>\n  //       <p className='creat-box--label'>+ Lisp</p>\n  //     </div>\n  //   </div>\n  // )\n\n  const addMDBox = (\n    <div className='add-box--group'\n      onClick={ (e) => {\n        e.stopPropagation()\n        // this.setState({ opened : false })\n        addNew(createNewMarkdown()) }\n      }\n    >\n      <div\n        className='plusBtn'\n        title='Create new MarkDown box'\n      >\n        <p className='create-box--big'>M&darr;</p>\n        <p className='creat-box--label'>+ Markdown</p>\n      </div>\n    </div>\n  )\n\n  return (\n    <div className='box-top-bar--modal--pick-box-type'>\n      <div className='modal--create-box'>\n        <div className='modal--create-box--container'>\n          { addLambdaBox }\n          {/* { addLispBox } */}\n          { addMDBox }\n        </div>\n      </div>\n    </div>\n  )\n}","import React, { Component } from 'react'\n\nimport { BoxState, GlobalSettings } from '../Types'\n\nimport \"../styles/CreateBox.css\"\nimport PickBoxTypeModal from './PickBoxTypeModal'\n\ninterface Props {\n  addNew : (box : BoxState) => void\n  settings : GlobalSettings\n}\n\ninterface State {\n  modalOpen : boolean\n}\n\n// TODO: this needs to change\n// somehow I need to be able to delegate choosing the specific subtype of the Box\nexport default class CreateBox extends Component <Props, State> {\n  constructor (props : Props) {\n    super(props)\n\n    this.state = {\n      modalOpen : false\n    }\n  }\n\n  render () : JSX.Element {\n    const { addNew } : Props = this.props\n    const { modalOpen } = this.state\n   \n    if (this.state.modalOpen === false) {\n      return (\n        <div className='create-box-plus' onClick={ () => this.setState({ modalOpen : ! modalOpen }) } >\n          <div className='create-box-plus--button'>\n            <i className=\"fas fa-plus\" />\n          </div>\n        </div>\n      )\n    }\n    else {\n      return (\n        <PickBoxTypeModal\n          addNew={ (box : BoxState) => {\n            addNew(box)\n            this.setState({ modalOpen : false })\n          } }\n          settings={ this.props.settings }\n        />\n      )\n    }\n  }\n}\n  \n","import React from 'react'\n\nimport { ASTVisitor, Lambda, Variable, Beta, AST, Application, ChurchNumeral, Expansion, Macro, ASTReduction, Alpha, Gama, ASTReductionType } from \"@lambdulus/core\"\nimport { Breakpoint } from './Types'\nimport { reportEvent } from '../misc';\nimport { MacroBeta } from './AppTypes';\n\n\nexport default class ReactPrinter extends ASTVisitor {\n  private rendered : JSX.Element | null = null\n  private argument : Variable | null = null\n\n  // TODO: this is just temporary and very dirty hot fix\n  // because findSimplifiedReduction needs to get clonned tree\n  // because it modifies that tree even thought it probably shoudl not\n  // actual tree being printed is not the same\n  // this then leads to some problem when expression is being copied (argument used mutliple times inside lambda)\n  // and one of them is then identified as a REDEX\n  // because all of them share same Identifier --> all of them are identified as a redex\n  // private foundRedexes : Array<symbol> = []\n  // on the other hand -- this is not so dirty right?\n  private redexesFound : number = 0 // 0 is empty ; 1 is found ; -1 is blocked and can't be set to 1 again\n  // NOW: be very careful\n  // this solution unfortunately combines both of the original solutions and this means it probably takes\n  // the worst of both of them\n  // what it means is this:\n  // it relies on correct logic that sets reduction.topLevelParent\n  // there could very well be bug and it could work badly\n  // also it relies on order\n  // once the redexFound was set to 1 it will be set to -1 and then it cannot be set again\n  // this means - I efectively say - only first occurence of the expression can be the REDEX\n  // be very aware that this might be very ill and really buggy\n  //\n  //\n  // final decision is to dith all of the above\n  // and just go with counting --> logic seems sound --> if I arrive somewhere first when printing\n  // in the same order I look for the redexes (in normal order at least I hope) --> it should be redex\n  // rest is fake\n\n  private printMultiLambda (lambda : Lambda, accumulator : JSX.Element) : void {\n    if (lambda.body instanceof Lambda) {\n      const context : Variable = lambda.body.argument\n      let className : string = 'argument'\n      let title : string = ''\n\n      if (this.isBreakpoint(lambda.body.argument)) {\n        className += ' breakpoint'\n        title = 'Will break on substitution'\n      }\n\n      // bug@highlight-alpha\n      let set = false\n      if (this.reduction instanceof Alpha\n            &&\n          Array.from(this.reduction.conversions).some((conversion : Lambda) => {\n            return conversion.identifier === lambda.body.identifier\n          })\n          ) {\n              this.argument = context\n              set = true\n              className += ' alpha'\n      }\n\n      // TO JE KVULI FIXU MULTILAMBDA FACCT 3 beta redukce nad shadowingem\n      let argument : Variable | null = this.argument\n      if (this.argument !== lambda.body.argument\n          &&\n          this.argument !== null\n          &&\n          this.argument.name() === lambda.body.argument.name()) {\n        this.argument = null\n      } // TO JE KVULI FIXU MULTILAMBDA FACCT 3 beta redukce nad shadowingem\n\n      // TODO: same here\n      if (this.argument\n          &&\n          this.argument.name() === context.name()) {\n            className += ' substitutedArg'\n        }\n\n      const args : JSX.Element = (\n        <span className='arguments'>\n          { accumulator } {' '}\n          <span\n            className={ className }\n            title={ title }\n            onClick={ () => {\n              (context as any).identifier = Symbol()\n              this.onClick({ type : ASTReductionType.BETA, context, broken : new Set() })\n              reportEvent('Breakpoint added to argument', 'Breakpoint was added', '')\n            }\n            }\n          >\n            { context.name() }\n          </span>\n        </span>\n      )\n      \n      this.printMultiLambda(lambda.body, args)\n      if (set === true) {\n        this.argument = null\n      }\n      this.argument = argument // TO JE KVULI FIXU MULTILAMBDA FACCT 3 beta redukce nad shadowingem\n    }\n    else {\n      lambda.body.visit(this)\n      const body : JSX.Element | null = this.rendered\n      this.rendered = accumulator\n\n      this.rendered = (\n        <span className='function'>\n          (\n          <span\n            className='lambda'\n            >\n              λ { ' ' }\n          </span>\n          { accumulator } . { body }\n          )\n        </span>\n      )\n    }\n  }\n\n  isBreakpoint (node : AST) : boolean {\n    for (const breakpoint of this.breakpoints) {\n      if (breakpoint.context.identifier === node.identifier) {\n        return true\n      }\n    }\n    return false\n  }\n\n  constructor (\n    public readonly tree : AST,\n    private readonly onClick : (breakpoint : Breakpoint) => void,\n    private readonly reduction : ASTReduction,\n    private readonly breakpoints : Array<Breakpoint>,\n    private readonly SDE : boolean,\n  ) {\n    super()\n    this.tree.visit(this)\n  }\n\n  print () : JSX.Element | null {\n    return this.rendered\n  }\n\n  // TODO: little bit refactored, maybe keep going\n  onApplication (application: Application) : void {\n    let className : string = 'application'\n    let leftClassName : string = 'left'\n    let rightClassName : string = 'right'\n    let set : boolean = false\n    let redex : AST | null = null\n\n    if (this.reduction instanceof Beta) {\n      redex = this.reduction.redex\n    }\n\n    if (this.reduction instanceof MacroBeta) {\n      // if (this.redexFound === 0 && application.identifier === this.reduction.topLevelParent.identifier) {\n      //   this.redexFound = 1\n      //   redexFoundFlag = true\n      //   debugger\n      // }\n      \n      //  === 1 && \n      if (this.redexesFound < this.reduction.arity && this.reduction.applications.some((app : Application) => app.identifier === application.identifier)) {\n        if (application.left instanceof Macro) {\n          leftClassName += ' extended-redex'\n        }\n\n        this.redexesFound++\n        \n        rightClassName += ' extended-redex'\n        // console.log('bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb')\n      }\n    }\n\n    if (this.reduction instanceof Gama && this.reduction.args.includes(application)) {\n      className += ' redex abstraction argument'\n    }\n\n    // else if (this.reduction instanceof Expansion) {\n    //   redex = this.reduction.target\n    // } // to asi neni uplne potreba tady\n\n    if (redex !== null\n          &&\n        redex.identifier === application.identifier // tohle je asi trosku useles\n          &&\n        redex === application\n      ) {\n        leftClassName += ' redex'\n        rightClassName += ' redex'\n\n        // TODO: this is probably not good and should be done other way\n\n        if (application.left instanceof Lambda) {\n          this.argument = application.left.argument\n          set = true\n        }\n    }\n\n    if (application.right instanceof Application) {\n      application.left.visit(this)\n      const left : JSX.Element | null = <span className={ leftClassName }>{this.rendered}</span>\n\n      // tohle delam proto, ze se nesmi vypnout this.argument u libovolne aplikace, jenom u te ktera ho setnula\n      // priklad + 2 3 a krokuj - zakomentuj a krokuj znovu Y se bude chovat spatne hned v prvnich krocich\n      if (set) {\n        this.argument = null\n      }\n\n      application.right.visit(this)\n      const right : JSX.Element | null = <span className={ rightClassName }>( { this.rendered } )</span>\n\n      this.rendered =\n      <span className={ className }>\n        { left } { right }\n      </span>\n    }\n    else {\n      application.left.visit(this)\n      const left : JSX.Element | null = <span className={ leftClassName }>{this.rendered}</span>\n\n      // tohle delam proto, ze se nesmi vypnout this.argument u libovolne aplikace, jenom u te ktera ho setnula\n      // priklad + 2 3a krokuj - zakomentuj a krokuj znovu Y se bude chovat spatne hned v prvnich krocich\n      if (set) {\n        this.argument = null\n      }\n\n      application.right.visit(this)\n      const right : JSX.Element | null = <span className={ rightClassName }>{ this.rendered }</span>\n\n      this.rendered =\n      <span className={ className }>\n        { left } { right }\n      </span>\n    }\n  }\n  \n  // TODO: little bit refactored, maybe keep going\n  onLambda (lambda: Lambda) : void {\n    // TODO: this also seems not so elegant and clean\n\n    let title : string = ''\n\n    let argument : Variable | null = this.argument\n    if (this.argument !== lambda.argument\n        &&\n        this.argument !== null\n        &&\n        this.argument.name() === lambda.argument.name()) {\n      this.argument = null\n    }\n\n\n    // multilambda\n    if (lambda.body instanceof Lambda) {\n      const context : Variable = lambda.argument\n      let className : string = 'argument'\n\n      if (this.isBreakpoint(lambda.argument)) {\n        className += ' breakpoint'\n        title = 'Will break on substitution'\n      }\n\n      // TODO: same here\n      if (this.argument\n        &&\n        this.argument.name() === context.name()) {\n          className += ' substitutedArg'\n      }\n\n      // if (this.reduction instanceof Alpha) {\n      //   className += ' alpha'\n      // }\n\n      const acc : JSX.Element = (\n        <span\n          className={ className }\n          title={ title }\n          onClick={ () => {\n            (context as any).identifier = Symbol()\n            this.onClick({ type : ASTReductionType.BETA, context, broken : new Set() })\n            reportEvent('Breakpoint added to argument', 'Breakpoint was added', '')\n          }\n          }\n        >{ lambda.argument.name() }\n        </span>\n      )\n\n      this.printMultiLambda(lambda, acc)\n    }\n    else {\n      const context : Variable = lambda.argument\n\n      // lambda.argument.visit(this)\n      \n      // const args : JSX.Element | null = this.rendered\n\n      lambda.body.visit(this)\n      const body : JSX.Element | null = this.rendered\n\n      let className : string = 'argument'\n      let title : string = ''\n\n      if (this.isBreakpoint(lambda.argument)) {\n        className += ' breakpoint'\n        title = 'Will break on substitution'\n      }\n\n      // TODO: same here\n      if (this.argument\n        &&\n        this.argument.name() === context.name()) {\n          className += ' substitutedArg'\n      }\n\n      this.rendered = (\n        <span className='function' >\n          (\n          <span\n            className='lambda'\n            >\n              λ { ' ' }\n          </span>\n          <span\n            className='arguments'\n            onClick={ () => {\n              (context as any).identifier = Symbol()\n              // TODO: for now it does nothing - maybe delete in the future            \n              // this.onClick({ type : Beta, context, broken : new Set })\n              // reportEvent('Breakpoint added to argument', 'Breakpoint was added', '')\n            }\n            }\n          >\n            <span\n                className={ className }\n                title={ title }\n                onClick={ () => {\n                  (context as any).identifier = Symbol()\n                  this.onClick({ type : ASTReductionType.BETA, context, broken : new Set() })\n                  reportEvent('Breakpoint added', 'Breakpoint was added', '')\n                }\n                }\n            >\n              { lambda.argument.name() }\n            </span>\n            { ' ' }\n          </span>\n          . { body } \n          )\n        </span>\n      )\n    }\n\n    this.argument = argument\n    if (argument !== null) {\n      this.argument = argument\n    }\n  }\n  \n  // TODO: little bit refactored, maybe keep going\n  onChurchNumeral (churchNumber: ChurchNumeral) : void {\n    let className : string = 'churchnumeral'\n    let redex : AST | null = null\n    let redexClass : string = ' redex'\n    let title : string = ''\n\n    if (this.reduction instanceof Expansion) {\n      redex = this.reduction.target\n    }\n\n    if (this.reduction instanceof Gama && this.reduction.args.includes(churchNumber)) {\n      className += ' redex abstraction argument'\n    }\n\n    if (redex !== null\n          &&\n        redex.identifier === churchNumber.identifier\n          &&\n        redex === churchNumber\n      ) {\n        className += redexClass\n    }\n\n    if (this.isBreakpoint(churchNumber)) {\n      className += ' breakpoint'\n      title = 'Will break on Expansion'\n    }\n\n    this.rendered = (\n      <span\n        className={ className }\n        title={ title }\n        onClick={ () => {\n          (churchNumber as any).identifier = Symbol()\n          this.onClick({ type: ASTReductionType.EXPANSION, context : churchNumber, broken : new Set() })\n          reportEvent('Breakpoint added to ChurchNumeral', 'Breakpoint was added', '')\n        }\n        }\n      >\n        { churchNumber.name() }\n      </span>\n    )\n  }\n\n  // TODO: little bit refactored, maybe keep going  \n  onMacro (macro: Macro) : void {\n    // console.log(this.reduction)\n    let className = 'macro'\n    let redex : AST | null = null\n    let redexClass : string = ' redex'\n    let title : string = ''\n\n    if (this.reduction instanceof Expansion) {\n      redex = this.reduction.target\n    }\n\n    if (this.reduction instanceof Gama) {\n      if (this.reduction.redexes.includes(macro)) {\n        [ redex ] = this.reduction.redexes\n        className += redexClass + ' abstraction'\n      }\n\n\n      if (this.reduction.args.includes(macro)) {\n        className += redexClass + ' abstraction argument'\n      }\n    }\n\n    if (this.reduction instanceof MacroBeta) {\n      \n      if (macro.identifier === this.reduction.applications[0].left.identifier) {\n        className += ' abstraction'\n        // console.log('............................................------------------.................................')\n      }\n      // console.log(\"MMMMMMMMMMMMMMMMACROBEEEEEEEEEEEEEEEEEEEEEETAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\")\n\n    }\n\n\n    if (redex !== null\n          &&\n        redex.identifier === macro.identifier\n          &&\n        redex === macro\n        ) {\n      className += redexClass\n    }\n\n    if (this.isBreakpoint(macro)) {\n      className += ' breakpoint'\n      title = 'Will break on Expansion'\n    }\n\n    this.rendered = (\n      <span\n        className={ className }\n        title={ title }\n        onClick={ () => {\n          (macro as any).identifier = Symbol()\n          this.onClick({ type: ASTReductionType.EXPANSION, context : macro, broken : new Set() })\n          reportEvent('Breakpoint added to Macro', 'Breakpoint was added', '')\n        }\n        }\n      >\n        { macro.name() }\n      </span>\n    )\n  }\n  \n  onVariable (variable: Variable): void {\n    // TODO: same here - not so clean\n    let className : string = 'variable'\n\n    if (this.argument\n        &&\n        this.argument.name() === variable.name()) {\n          className += ' substitutedArg'\n          if (this.reduction instanceof Alpha) {\n            className += ' alpha'\n          }\n      }\n\n    this.rendered = <span className={ className } >{ variable.name() }</span>\n  }\n}","import React from 'react'\nimport { ASTReduction, ASTReductionType } from '@lambdulus/core' // , Eta\n\n\ninterface ReductionMessageProperties {\n  lastReduction : ASTReduction | null\n}\n\nexport default function ReductionMessage (props : ReductionMessageProperties) : JSX.Element {\n  const { lastReduction } = props\n\n  if (lastReduction === null) {\n    return null as any\n  }\n\n  if (lastReduction.type === ASTReductionType.BETA) {\n    return (\n      <p className='lastReduction'>\n        β reduction\n      </p>\n    )\n  }\n\n  if (lastReduction.type === ASTReductionType.ALPHA) {\n    return (\n      <p className='lastReduction'>\n        α conversion\n      </p>\n    )\n  }\n\n  if (lastReduction.type === ASTReductionType.EXPANSION) {\n    return (\n      <p className='lastReduction'>\n        Macro expansion\n      </p>\n    )\n  }\n\n  if (lastReduction.type === ASTReductionType.ETA) {\n    return (\n      <p className='lastReduction'>\n        η conversion\n      </p>\n    )\n  }\n\n  if (lastReduction.type === ASTReductionType.GAMA) {\n    return (\n      <p className='lastReduction'>\n        Simplified Beta Reduction\n      </p>\n    )\n  }\n\n  else {\n    return null as any\n  }\n  \n}","import React, { memo } from 'react'\nimport { ASTReduction, AST, MacroMap, None } from '@lambdulus/core'\n\nimport './styles/Step.css'\n\nimport ReactPrinter from './ReactPrinter'\nimport { EvaluationStrategy, StepRecord, Breakpoint, Evaluator, StepValidity } from './Types'\nimport ReductionMessage from './ReductionMessage'\nimport { strategyToEvaluator, findSimplifiedReduction, MacroBeta } from './AppTypes'\n\n\ninterface StepWrapperProperties {\n  stepRecord : StepRecord\n  breakpoints : Array<Breakpoint>\n  strategy : EvaluationStrategy\n  addBreakpoint (breakpoint : Breakpoint) : void\n  children : JSX.Element\n  lastStep : boolean\n  SDE : boolean\n  macrotable : MacroMap\n}\n\ninterface StepProperties {\n  stepRecord : StepRecord\n  breakpoints : Array<Breakpoint>\n  addBreakpoint (breakpoint : Breakpoint) : void\n  children : JSX.Element\n  strategy : EvaluationStrategy\n  lastStep : boolean\n  SDE : boolean\n  macrotable : MacroMap\n}\n\n// This is done because of highlighting - if Strategy is changed ->\n// old steps should not be re-highlighted with changed Strategy - but stay same\nconst StepMemo = memo(Step, (props : StepProperties) => !props.lastStep)\n\nexport default function StepWrapper (props : StepWrapperProperties) : JSX.Element {\n  // return(\n  //   <StrategyContext.Consumer>\n  //     { \n  //       (strategy : EvaluationStrategy) => <StepMemo { ...props } strategy={ strategy } />\n  //     }\n  //   </StrategyContext.Consumer>\n  // )\n  return(\n    <StepMemo { ...props } />\n  )\n}\n\nfunction Step (props : StepProperties) : JSX.Element | null {\n  const { stepRecord, addBreakpoint, breakpoints, children, strategy, SDE, macrotable } = props\n  const { ast : tree, lastReduction, step, message, exerciseStep } = stepRecord\n  const { validity } = message\n\n  if (tree === null) {\n    return null\n  }\n\n  // const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(tree)\n  const newast : AST = tree.clone()\n  let nextReduction = (() => {\n    if (SDE) {\n      return findSimplifiedReduction(newast, strategy, macrotable)[0]\n    }\n    else {\n      const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(tree)\n      return evaluator.nextReduction\n    }\n  })()\n\n  if ( ! (nextReduction instanceof MacroBeta) && !(nextReduction instanceof None)) {\n    // TODO: read carefully\n    // this means -- next reduction is gonna be normal stuff (Beta, Alpha, Expansion)\n    // because of some decision to structure the findSimplifiedReduction the way it works\n    // mainly := first clone the tree and then mutate it with each recursive call\n    // if it's the normal stuff --> then the tree I used to identify the redex is not the same tree as I am giving to the ReactPrinter\n    // for this reason I have to use redex finder which does not mutate the tree under my hands at least until I rewrite\n    // the findSimplifiedReduction\n    const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(tree)\n    nextReduction = evaluator.nextReduction\n    // TODO: read carefully\n    // this definitely needs to be fixed\n    // I will most certainly need to do some dirty magic in ReactPrinter - because this design also makes it impossible\n    // to decide what is current redex in expressions like:\n    // (λ x . + x x) ( + 1 2 )\n    // + [( + 1 2 )] [( + 1 2 )]\n    // both [( + 1 2 )] are highlighted\n    // but maybe its not related to this\n  }\n  const reduction : ASTReduction = nextReduction\n  const printer : ReactPrinter = new ReactPrinter(tree, addBreakpoint, reduction, breakpoints, SDE)\n\n  // const incorrectStep : boolean = stepRecord.message.indexOf('Incorrect step.') === 0\n  // const correctStep : boolean = stepRecord.message.indexOf('Correct.') === 0\n  // const exerciseStep : boolean = incorrectStep || correctStep\n\n  return (\n    <span className='step'>\n      <ReductionMessage lastReduction={ lastReduction } />\n      <div className='inlineblock' >\n        <p className='stepNumber' >\n          { step } :\n        </p>\n        { printer.print() }\n        { children }\n        {\n          stepRecord.message.message === '' ?\n            null\n            :\n            exerciseStep === false ?\n            <p className='stepMessage' >\n              { stepRecord.message.message }\n            </p>\n            :\n            validity === StepValidity.INCORRECT ?\n              <span>\n                <p className='stepMessage incorrect' >\n                  Your input is incorrect!\n                  <br /> It was: \n                    <i className='userInput'>`{ stepRecord.message.message.substr(15) }`</i>\n                  <br />\n                </p>\n                <p className='stepMessage'>Continue from the next step please.</p>\n              </span>\n            :\n              <p className='stepMessage correct' >\n                { stepRecord.message.message }\n              </p>\n        }\n      </div>\n    </span>\n  )\n}","import React from 'react'\n\nimport Step from './Step'\n// import { AddBoxContext } from './MethodInjector'\nimport { Breakpoint, StepRecord, UntypedLambdaState, EvaluationStrategy } from './Types'\nimport { MacroMap } from '@lambdulus/core'\n// import { DeleteBox, MakeActiveContext } from './BoxSpace'\n\ninterface InactiveExpressionProps {\n  className : string\n  breakpoints : Array<Breakpoint>\n  history : Array<StepRecord>\n  strategy : EvaluationStrategy\n  SDE : boolean\n  macrotable : MacroMap\n\n  createBoxFrom (stepRecord : StepRecord, macrotable : MacroMap) : UntypedLambdaState\n}\n\n\nexport default function InactiveExpression (props : InactiveExpressionProps) : JSX.Element {\n  const { className, SDE, macrotable } = props\n  // const deleteBox = useContext(DeleteBox)\n  // const makeActive = useContext(MakeActiveContext)\n\n  return (\n    <div\n      className={ className + ' inactiveBox' }\n    >\n      <ul className='UL'>\n        <li key={ 0 } className='activeStep LI'>\n          <Step\n            breakpoints={ props.breakpoints }\n            strategy={ props.strategy }\n            addBreakpoint={ () => {} } // blank function - NOOP\n            stepRecord={ props.history[0] }\n            lastStep={ false }\n            SDE={ SDE }\n            macrotable={ macrotable }\n          >\n            <p></p>\n          </Step>\n        </li>\n      </ul>\n      <p className='inactiveMessage'>\n        Collapsing { props.history.length - 1 } { props.history.length === 2 ? 'step' : 'steps' }. Click to activate this box.\n      </p>\n    </div>\n  )\n}\n\n// This was inside the <Step> </Step>\n/* <AddBoxContext.Consumer>\n              {\n                (addBox : (boxState : BoxState) => void) => <i\n                  className=\"hiddenIcon far fa-clone\"\n                  onClick={ () => addBox(props.createBoxFrom(props.history[0])) }\n                />\n              }\n            </AddBoxContext.Consumer> */","import React, { KeyboardEvent } from 'react'\nimport MonacoEditor from 'react-monaco-editor'\n\nimport '../styles/Editor.css'\n\n// import { EvaluationStrategy } from '../App'\n\n\nexport enum ActionType {\n  ENTER_EXPRESSION = 'Enter Expression',\n  ENTER_EXERCISE = 'Enter Exercise',\n  NEXT_STEP = 'Next Step',\n  RUN = 'Run',\n  ENTER_MD = 'Enter MarkDown',\n}\n\ninterface EditorProperties {\n  placeholder: string\n  content : string\n  syntaxError : Error | null\n  submitOnEnter : boolean\n  shouldReplaceLambda : boolean\n  darkmode : boolean\n  \n  onContent (content : string) : void\n  onShiftEnter () : void\n  onCtrlEnter () : void\n  onEnter () : void\n  onExecute () : void // TODO:delete\n  // onReset () : void\n}\n\nexport default function Editor (props : EditorProperties) : JSX.Element {\n  const {\n    placeholder,\n    content,\n    syntaxError,\n    submitOnEnter,\n    shouldReplaceLambda,\n    darkmode,\n\n    onContent,\n    onEnter,\n    onShiftEnter,\n    onCtrlEnter,\n    // onExecute,\n  } : EditorProperties = props\n\n  const onChange = (content : string) => {\n    // let { target : { value : content } } : { target : { value : string } } = event\n    // const caretPosition : number = event.target.selectionEnd\n\n    if (shouldReplaceLambda) {\n      content = content.replace(/\\\\/g, 'λ')\n    }\n    \n    onContent(content)\n  }\n\n  // TODO: Editor should not decide that - it should only implement onEnter onShiftEnter onCtrlEnter\n  const onKeyDown = (event : KeyboardEvent<HTMLDivElement>) => {\n    if ( ! event.shiftKey && ! event.ctrlKey && event.key === 'Enter') {\n      \n      if (submitOnEnter) {\n        event.stopPropagation()\n        event.preventDefault()\n        onEnter()\n      }\n\n      return\n    }\n\n    if (event.shiftKey && event.key === 'Enter') {\n      event.preventDefault()\n      onShiftEnter()\n    }\n    if (event.ctrlKey && event.key === 'Enter') {\n      event.preventDefault()\n      onCtrlEnter()\n    }\n\n    // TODO: not yet\n    // if (event.ctrlKey && event.key === 'r') {\n    //   event.preventDefault()\n    //   onReset()\n    // }\n  }\n\n  return (\n    <div className='editorContainer'>\n      {\n        syntaxError ?\n        <p className='editorError'>\n          { `${syntaxError}` }\n        </p>\n        :\n        null\n      }\n\n      <div className=\"editor\">\n        <InputField\n          placeholder={ placeholder }\n          content={ content }\n          darkmode={ darkmode }\n          onContent={ (content : string) => onChange(content) }\n          onKeyDown={ onKeyDown }\n        />\n      </div>\n    </div>\n  )\n}\n\ninterface InputProps {\n  placeholder : string\n  content : string\n  darkmode : boolean\n  // onChange (event : ChangeEvent<HTMLTextAreaElement>) : void\n  onContent (content : string) : void\n  onKeyDown (event : KeyboardEvent<HTMLDivElement>) : void\n}\n\nfunction InputField (props : InputProps) : JSX.Element {\n  const { content, darkmode, onKeyDown, onContent } : InputProps = props\n  const lines : number = content.split('\\n').length\n\n\n  return (\n    <div\n      onKeyDownCapture={ onKeyDown }\n    >\n      <MonacoEditor\n        // width=\"800\"\n        height={ Math.max(5 * 19 ,Math.min(40 * 19, (lines + 1) * 19)) } // 10 lines by default\n        language=\"markdown\"\n        theme= { darkmode ? 'vs-dark' : 'vs-light' }\n        value={ content }\n        options={ {\n          formatOnPaste : true,\n          minimap : { enabled : false },\n          renderLineHighlight : \"none\",\n          scrollBeyondLastLine : false,\n          overviewRulerBorder : false,\n          scrollbar : {\n            // handleMouseWheel : false,\n          } } }\n        onChange={ (content : string) => onContent(content) }\n        // editorDidMount={ ::this.editorDidMount }\n        editorDidMount={ (editor, monaco) => editor.focus() }\n      />\n    </div>\n  )\n}","import React, { PureComponent } from 'react'\n\nimport '../styles/DebugControls.css'\n\n\ninterface Props {\n  isRunning : boolean\n  // disableRun : boolean /* TODO: this is just for now -- because I am not sure students will know how to exercise with simplified */\n\n  onStep : () => void\n  onRun : () => void\n}\n\n// TODO: Consider separating the `keydown` event handler into different file\n// it would be singleton module, which would make sure ONLY ONE `DebugControls` component\n// is subscribed to the `keydown` event\nexport default class DebugControls extends PureComponent<Props> {\n  componentDidMount () : void {\n    document.onkeydown = (event) => {\n      console.log('KEYDOWN', event.key)\n      if ( ( ! event.shiftKey)\n        && ( ! event.ctrlKey)\n        && ( ! event.altKey)\n        && ( ! event.metaKey)\n        && (event.key === 'F8' || event.key === 'F9')) {\n          if (event.key === 'F8') {\n            event.preventDefault()\n            this.props.onStep()\n          }\n          if (event.key === 'F9') { /* TODO: this is just for now -- because I am not sure students will know how to exercise with simplified */\n            event.preventDefault()\n            this.props.onRun()\n          }\n        }\n    }\n  }\n\n  componentWillUnmount () : void {\n    document.onkeydown = () => void 0\n  }\n\n  render () {\n    const { isRunning, onStep, onRun } : Props = this.props\n  \n    const runMessage : string =\n      isRunning ? 'Stop the Evaluation (Press F9)' :  'Evaluate the Expression (Press F9)'\n\n    return (\n      <div className='debug-controls'>\n        {\n          /* TODO: this is just for now -- because I am not sure students will know how to exercise with simplified */\n          // this.props.disableRun ?\n            // null\n          // :\n          <button\n            title={ runMessage }\n            type=\"button\"\n            className='btn debug-controls--run'\n            onClick={ onRun }\n          >\n            <span className='debug-controls--btn-label'>{ isRunning ? 'Stop' : 'Run' }</span>\n            <i className=\"mini-icon fas fa-play\"></i>\n          </button>\n        }\n        \n        \n        <button\n          title='Evaluate Next Step (Press F8)'\n          type=\"button\"\n          className='btn debug-controls--step'\n          onClick={ onStep }\n          disabled={ isRunning }\n        >\n          <span className='debug-controls--btn-label'>Step</span>\n          <i className=\"mini-icon fas fa-step-forward\"></i>\n        </button>\n      </div>\n    )\n  }\n\n}"," import React, { PureComponent } from 'react'\n\nimport Step from './Step'\nimport { UntypedLambdaState, Breakpoint, StepRecord, UntypedLambdaExpressionState } from './Types'\nimport Editor from '../components/Editor'\nimport { mapLeftFromTo } from '../misc'\nimport DebugControls from '../components/DebugControls'\n\nimport './styles/Expression.css'\n\ninterface EvaluatorProps {\n  className : string\n  state : UntypedLambdaExpressionState\n  breakpoints : Array<Breakpoint>\n  history : Array<StepRecord>\n  editor : {\n    placeholder : string\n    content : string\n    syntaxError : Error | null\n  }\n  isNormalForm : boolean\n  isExercise : boolean\n  darkmode : boolean\n\n  createBoxFrom (stepRecord : StepRecord) : UntypedLambdaState\n  setBoxState (state : UntypedLambdaExpressionState) : void\n  onContent (content : string) : void\n  onEnter () : void\n  onExecute () : void\n  addBox (box : UntypedLambdaState) : void\n  shouldShowDebugControls : boolean\n}\n\nexport default class Expression extends PureComponent<EvaluatorProps> {\n  constructor (props : EvaluatorProps) {\n    super(props)\n\n    this.addBreakpoint = this.addBreakpoint.bind(this)\n  }\n\n  render () : JSX.Element {\n    const { className, state, editor, shouldShowDebugControls, isExercise, darkmode } = this.props\n\n    const { isRunning, SDE, macrotable } : UntypedLambdaExpressionState = state\n\n    const {\n      placeholder,\n      content,\n      syntaxError,\n    } = editor\n\n    // this is just a dirty-quick implementation to get an unique identifier\n    const array = new Uint32Array(2)\n    window.crypto.getRandomValues(array)\n    // const uniq : string = `${Date.now()}-${Math.random()}-${array[0]}-${array[1]}`\n\n\n\n    return (\n      <div className={ className }>\n        <ul className='UL'>\n          {\n            mapLeftFromTo(0, this.props.history.length - 2, this.props.history, (stepRecord : StepRecord, i : Number) =>\n              <li key={ i.toString() } className='inactiveStep LI' >\n                <Step\n                  breakpoints={ this.props.breakpoints }\n                  strategy={ this.props.state.strategy }\n                  addBreakpoint={ () => {} }\n                  stepRecord={ stepRecord }\n                  lastStep={ false }\n                  SDE={ SDE }\n                  macrotable={ macrotable }\n                >\n                  <i\n                    className=\"hiddenIcon far fa-clone\"\n                    title='Clone this expression to the new box'\n                    onClick={ (e : any) => {\n                      e.stopPropagation()\n                      this.props.addBox(this.props.createBoxFrom(stepRecord))\n                    } }\n                  />\n                </Step>\n              </li>)\n          }\n          <li key={this.props.history.length - 1} className='activeStep LI'>\n            <Step\n              breakpoints={ this.props.breakpoints }\n              strategy={ this.props.state.strategy }\n              addBreakpoint={ this.addBreakpoint }\n              stepRecord={ this.props.history[this.props.history.length - 1] }\n              lastStep={ true }\n              SDE={ SDE }\n              macrotable={ macrotable }\n            >\n                <i\n                  className=\"hiddenIcon far fa-clone\"\n                  title='Clone this expression to the new box'\n                  onClick={ (e : any) => {\n                    e.stopPropagation() // TODO: maybe I shouldn't do this\n                    // maybe instead I should drop the `focusedBoxIndex` and stop caring if Box has been clicked\n                    // instead I could always render whole and complete Box if user does not collapsed it\n                    // I need to think this through\n                    this.props.addBox(this.props.createBoxFrom(this.props.history[this.props.history.length - 1]))\n                   } }\n                />\n            </Step>\n          </li>\n        </ul>\n        {\n          (isExercise && ! this.props.isNormalForm) ?\n            <div>\n\n              <Editor\n                placeholder={ placeholder } // data\n                content={ content } // data\n                syntaxError={ syntaxError } // data\n                submitOnEnter={ true } // data\n                darkmode={ darkmode }\n\n                onContent={ this.props.onContent } // fn\n                onEnter={ this.props.onEnter } // fn // tohle asi bude potreba\n                onShiftEnter={ () => void 0 }\n                onCtrlEnter={ () => void 0 }\n                onExecute={ this.props.onExecute } // fn // tohle asi bude potreba\n                shouldReplaceLambda={ true }\n              />\n\n\n              {/* <div className='untyped-lambda--pick-strategy untyped-lambda-settings-strategies inlineblock'>\n                <p className='stratsLabel inlineblock'>Strategy:</p>\n\n                <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n                  <input\n                    id={ `untyped-lambda-settings--normal-strategy-${uniq}` }\n                    type='radio'\n                    name={ `untyped-lambda-settings--strategy-${uniq}` }\n                    // style=\"fill\"\n                    checked={\n                      strategy === EvaluationStrategy.NORMAL\n                    }\n\n                    onChange={\n                      () => setBoxState({ ...state, strategy : EvaluationStrategy.NORMAL })\n                    }\n                  />\n                  <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--normal-strategy-${uniq}` }>\n                    Normal\n                  </label>\n                </span>\n\n                <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n                  <input\n                    id={ `untyped-lambda-settings--applicative-strategy-${uniq}` }\n                    type='radio'\n                    name={ `untyped-lambda-settings--strategy-${uniq}` }\n                    // style=\"fill\"\n                    checked={\n                      strategy === EvaluationStrategy.APPLICATIVE\n                    }\n                    \n                    onChange={\n                      () => setBoxState({ ...state, strategy : EvaluationStrategy.APPLICATIVE })\n                    }\n                  />\n                  <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--applicative-strategy-${uniq}` }>\n                    Applicative\n                  </label>\n                </span>\n              </div> */}\n\n              {/* Here add SDE switch/checkbox */}\n              {/* {\n                  <span\n                    className='untyped-lambda-settings-SDE-'\n                    title='Simplified Evaluation'>\n                    <input\n                      id={ `untyped-lambda-settings--SDE-${uniq}` }\n                      type='checkbox'\n                      checked={ SDE }\n                      disabled={ false }\n                      // shape=\"fill\"\n                      \n                      onChange={\n                        (e : ChangeEvent<HTMLInputElement>) => // tady nejakej destructuring\n                          setBoxState({ ...state, SDE : e.target.checked })\n                      }\n                    />\n                    <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--SDE-${uniq}` }>\n                      Simplified Evaluation\n                    </label>\n                  </span>\n                } */}\n\n                {\n                  // <span\n                  //   className='untyped-lambda-settings-SLI-'\n                  //   title='Single Letters as Names without Spaces'>\n                  //   <input\n                  //     id={ `untyped-lambda-settings--SLI-${uniq}` }\n                  //     type='checkbox'\n                  //     checked={ SLI }\n                  //     disabled={ false } // TODO: tohle bude rozhodne chtit prepsat\n                  //     // shape=\"fill\"\n                      \n                  //     onChange={\n                  //       (e : ChangeEvent<HTMLInputElement>) => // tady nejakej destructuring\n                  //         setBoxState({ ...state, SLI : e.target.checked })\n                  //     }\n                  //   />\n                  //   <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--SLI-${uniq}` }>\n                  //     Single Letter Names\n                  //   </label>\n                  // </span>\n                }\n\n            </div>\n          :\n            ( ! this.props.isNormalForm && shouldShowDebugControls) ?\n              <div style={ { height: '2.5em' } }>\n                <span className='untyped-lambda--debug-ctrl'>\n                  <DebugControls\n                    isRunning={ isRunning }\n                    onStep={ this.props.onEnter }\n                    onRun={ this.props.onExecute }\n                    // disableRun={ SDE }\n                  />\n                </span>\n                \n                {/* <div className='untyped-lambda--pick-strategy untyped-lambda-settings-strategies inlineblock'>\n                  <p className='stratsLabel inlineblock'>Strategy:</p>\n\n                  <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n                    <input\n                      id={ `untyped-lambda-settings--normal-strategy-${uniq}` }\n                      type='radio'\n                      name={ `untyped-lambda-settings--strategy-${uniq}` }\n                      // style=\"fill\"\n                      checked={\n                        strategy === EvaluationStrategy.NORMAL\n                      }\n\n                      onChange={\n                        () => setBoxState({ ...state, strategy : EvaluationStrategy.NORMAL })\n                      }\n                    />\n                    <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--normal-strategy-${uniq}` }>\n                      Normal\n                    </label>\n                  </span>\n\n                  <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n                    <input\n                      id={ `untyped-lambda-settings--applicative-strategy-${uniq}` }\n                      type='radio'\n                      name={ `untyped-lambda-settings--strategy-${uniq}` }\n                      // style=\"fill\"\n                      checked={\n                        strategy === EvaluationStrategy.APPLICATIVE\n                      }\n                      \n                      onChange={\n                        () => setBoxState({ ...state, strategy : EvaluationStrategy.APPLICATIVE })\n                      }\n                    />\n                    <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--applicative-strategy-${uniq}` }>\n                      Applicative\n                    </label>\n                  </span>\n                </div> */}\n\n                {/* Here add SDE switch/checkbox */}\n                {/* {\n                  <span\n                    className='untyped-lambda-settings-SDE-'\n                    title='Simplified Evaluation'>\n                    <input\n                      id={ `untyped-lambda-settings--SDE-${uniq}` }\n                      type='checkbox'\n                      checked={ SDE }\n                      disabled={ false }\n                      // shape=\"fill\"\n                      \n                      onChange={\n                        (e : ChangeEvent<HTMLInputElement>) => // tady nejakej destructuring\n                          setBoxState({ ...state, SDE : e.target.checked })\n                      }\n                    />\n                    <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--SDE-${uniq}` }>\n                      Simplified Evaluation\n                    </label>\n                  </span>\n                } */}\n\n                {/* <span\n                  className='untyped-lambda-settings-SLI-'\n                  title='Single Letters as Names without Spaces'>\n                  <input\n                    id={ `untyped-lambda-settings--SLI-${uniq}` }\n                    type='checkbox'\n                    checked={ SLI }\n                    disabled={ false } // TODO: tohle bude rozhodne chtit prepsat\n                    // shape=\"fill\"\n                    \n                    onChange={\n                      (e : ChangeEvent<HTMLInputElement>) => // tady nejakej destructuring\n                        setBoxState({ ...state, SLI : e.target.checked })\n                    }\n                  />\n                  <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--SLI-${uniq}` }>\n                    Single Letter Names\n                  </label>\n                </span> */}\n\n              </div>\n            :\n              null\n        }\n      </div>\n    )\n  }\n\n  addBreakpoint (breakpoint : Breakpoint) : void {\n    let { state, setBoxState, breakpoints } = this.props\n  \n    // const index : number = breakpoints.findIndex((brk : Breakpoint) => {\n    //   return brk.type === breakpoint.type && brk.context.identifier === breakpoint.context.identifier\n    // })\n    // \n    // if (index >= 0) {\n    //   breakpoints.splice(index, 1)\n    // }\n    // else {\n    //   breakpoints.push(breakpoint)\n    // }\n    // \n    // setBoxState({\n    //   ...state,\n    //   breakpoints,\n    // })\n\n    const brkpts : Array<Breakpoint> = breakpoints.filter((brk : Breakpoint) => {\n      return brk.type !== breakpoint.type || brk.context.identifier !== breakpoint.context.identifier\n    })\n\n    if (brkpts.length !== breakpoints.length) {\n      setBoxState({\n        ...state,\n        breakpoints : brkpts,\n      })\n    }\n    else {\n      setBoxState({\n        ...state,\n        breakpoints : [ ...breakpoints, breakpoint ]\n      })\n    }    \n  }\n}","import React, { PureComponent } from 'react'\n\nimport {\n  AST,\n  ASTReduction,\n  None,\n  Beta,\n  Lambda,\n  Variable,\n  Expansion,\n  ChurchNumeral,\n  Macro,\n  OptimizeEvaluator,\n  ASTReductionType,\n} from \"@lambdulus/core\"\n\nimport './styles/EvaluatorBox.css'\n\nimport { BoxType } from '../Types'\n\nimport InactiveEvaluator from './InactiveExpression'\nimport Expression from './Expression'\nimport { PromptPlaceholder, UntypedLambdaState, Evaluator, StepRecord, Breakpoint, UntypedLambdaType, UntypedLambdaExpressionState, StepMessage, StepValidity } from './Types'\nimport { reportEvent } from '../misc'\nimport { findSimplifiedReduction, MacroBeta, tryMacroContraction, strategyToEvaluator } from './AppTypes'\n\n\nexport interface EvaluationProperties {\n  state : UntypedLambdaExpressionState\n  isActive : boolean\n  isFocused : boolean\n  darkmode : boolean\n\n  setBoxState (state : UntypedLambdaExpressionState) : void\n  addBox (box : UntypedLambdaState) : void\n}\n\nexport default class ExpressionBox extends PureComponent<EvaluationProperties> {\n  constructor (props : EvaluationProperties) {\n    super(props)\n\n    this.onContent = this.onContent.bind(this)\n    this.onSimplifiedStep = this.onSimplifiedStep.bind(this)\n    this.onStep = this.onStep.bind(this)\n    this.onExecute = this.onExecute.bind(this)\n    this.onRun = this.onRun.bind(this)\n    this.onStop = this.onStop.bind(this)\n    this.shouldBreak = this.shouldBreak.bind(this)\n    this.createBoxFrom = this.createBoxFrom.bind(this)\n    this.onSimplifiedRun = this.onSimplifiedRun.bind(this)\n  }\n\n  render () : JSX.Element {\n    const { state, isActive, addBox, darkmode } : EvaluationProperties = this.props\n    const {\n      minimized,\n      history,\n      breakpoints,\n      editor,\n      SDE,\n      macrotable,\n    } : UntypedLambdaExpressionState = state\n\n    let className : string = 'box boxEval'\n    const { isNormalForm } = history.length ? history[history.length - 1] : { isNormalForm : false }\n\n    // TODO: Maybe I will take this out\n    // Frontend may take care of that\n    if (minimized) {\n      return (\n        <InactiveEvaluator\n          className={ className }\n          breakpoints={ breakpoints }\n          history={ history }\n          strategy={ this.props.state.strategy }\n          SDE={ SDE }\n          macrotable={ macrotable }\n          \n          createBoxFrom={ this.createBoxFrom }\n        />\n      )\n    }\n\n    return (\n      <Expression\n        className={ className }\n        isExercise={ false }\n        state={ state }\n        breakpoints={ breakpoints }\n        history={ history }\n        editor={ editor }\n        isNormalForm={ isNormalForm }\n        shouldShowDebugControls={ isActive }\n        darkmode={ darkmode }\n\n        createBoxFrom={ this.createBoxFrom }\n        setBoxState={ this.props.setBoxState }\n        onContent={ this.onContent }\n        onEnter={ this.onStep }\n        onExecute={ this.onExecute }\n        addBox={ addBox }\n      />\n    )\n  }\n\n  createBoxFrom (stepRecord : StepRecord) : UntypedLambdaState {\n    const { state } : EvaluationProperties = this.props\n    const {\n      strategy,\n      SLI,\n      SDE,\n      expandStandalones,\n      macrotable,\n    } : UntypedLambdaExpressionState = state\n    const { ast } = stepRecord\n    const content = ast.toString()\n\n    return {\n      __key : Date.now().toString(),\n      type : BoxType.UNTYPED_LAMBDA,\n      subtype : UntypedLambdaType.EMPTY,\n      title : `Copy of ${state.title}`,\n      minimized : false,\n      settingsOpen : true,\n      expression : \"\",\n      ast : null,\n      history : [],\n      isRunning : false,\n      breakpoints : [],\n      timeoutID : undefined,\n      timeout : 10,\n      strategy,\n      SDE,\n      SLI,\n      expandStandalones,\n      macrolistOpen : false,\n      macrotable : { },\n      editor : {\n        placeholder : PromptPlaceholder.EVAL_MODE,\n        content : Object.entries(macrotable).map(([name, definition] : [string, string]) => name + ' := ' + definition + ' ;\\n' ).join('') + content,\n        syntaxError : null,\n      }\n    }\n  }\n\n  onContent (content : string) : void {\n    const { state, setBoxState } = this.props\n\n    setBoxState({\n      ...state,\n      editor : {\n        ...state.editor,\n        content,\n        syntaxError : null,\n      }\n    })\n  }\n\n  onSimplifiedStep () : void {\n    // console.log(\"DOIN ONE STEP       _______     SIMPLIFIED\")\n\n    const { state, setBoxState } = this.props\n    const { strategy, history, macrotable } = state\n    const stepRecord = history[history.length - 1]\n    const { isNormalForm, step } = stepRecord\n    const ast = stepRecord.ast.clone()\n    let newast = ast\n\n    if (isNormalForm) {\n      return\n    }\n\n    // console.log('looooooooooooooooooooooooooooking')\n\n    //                                                    fix this part please\n    let [nextReduction, evaluateReduction] : [ASTReduction, (ast : AST) => AST] = findSimplifiedReduction(ast, strategy, macrotable)\n    // console.log('BACK TO THE WORLD HERE')\n    \n    let message : StepMessage = { validity : StepValidity.CORRECT, userInput : '', message : '' }\n    let isNowNormalForm = false\n\n    // console.log(nextReduction)\n\n    if (nextReduction instanceof MacroBeta) {\n      // console.log(\"YES MACRO BETA HERE\")\n      // z macrobeta si vytahnu aritu makra\n      const arity : number = nextReduction.arity\n\n      // a zkontroluju jestli velikost pole odpovida arite\n      if (nextReduction.applications.length !== arity) {\n        // pokud arita nesedi - je vetsi nez delka pole aplikaci -->\n        // --> musim vyhlasit warning a rict, ze tenhle krok neni uplne gooda\n        // console.log(\"ARITY IS WRONG - probably too few arguments\")\n        stepRecord.message.message = `Macro ${tryMacroContraction(nextReduction.applications[0].left, macrotable)} is given too few arguments.`\n\n        newast = evaluateReduction(newast)\n\n        // this.setState({\n        //   ...state,\n        // })\n        // return\n      }\n      else {\n        // this is what happens when ::single-step\n        //\n        newast = evaluateReduction(newast)\n        // debugger\n\n        // if we are not ::single-step --> findSimplifiedReduction won't return MacroBeta -- instead\n        // it will return the first redex --> first beta reduction in the list and then it's not macro reduction problem anymore\n        // so next consecutive redex search will just find pretty normal situation as it probably should\n      }\n    }\n    else if (nextReduction instanceof None) {\n      console.log('first is NONE')\n      const etaEvaluator : Evaluator = new OptimizeEvaluator(ast)\n\n      if (etaEvaluator.nextReduction instanceof None) {\n        console.log('second is NONE')\n\n        stepRecord.isNormalForm = true\n        stepRecord.message.message = 'Expression is in normal form.'\n        setBoxState({\n          ...state,\n        })\n        return\n      }\n\n      console.log('second is ',etaEvaluator.nextReduction)\n\n      newast = etaEvaluator.perform()\n      nextReduction = etaEvaluator.nextReduction\n    }\n    else {\n      newast = evaluateReduction(newast)\n    }\n\n\n    {\n      // console.log('copak se tohle vubec neprovadi????????????????')\n      const astCopy : AST = newast.clone()\n      const [nextReduction] : [ASTReduction, (ast : AST) => AST] = findSimplifiedReduction(astCopy, strategy, macrotable)\n      // const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n      \n      if (nextReduction instanceof None) {\n        const etaEvaluator : Evaluator = new OptimizeEvaluator(astCopy)\n        if (etaEvaluator.nextReduction instanceof None) {\n          isNowNormalForm = true\n          message.message = 'Expression is in normal form.'\n          \n          reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n        }\n      }\n    }\n\n    setBoxState({\n      ...state,\n      history : [ ...history, { ast : newast, lastReduction : nextReduction, step : step + 1, message, isNormalForm : isNowNormalForm, exerciseStep : false } ],\n    })\n\n    reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n    return\n    \n    // {\n    //   // None\n    //   // console.log(\"_________________________________ NONE\")\n    //   // stepRecord.isNormalForm = true\n    //   // stepRecord.message = 'Expression is in normal form.'\n      \n    //   // setBoxState({\n    //   //   ...state,\n    //   // })\n      \n    //   // reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n\n    //   // return\n    // }\n    // {\n    //   // Expansion -> then None\n    //   // stepRecord.lastReduction = newreduction\n    //   // stepRecord.isNormalForm = true\n    //   // stepRecord.message = 'Expression is in normal form.'\n      \n    //   // setBoxState({\n    //   //   ...state,\n    //   // })\n      \n    //   // reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n\n    //   // return\n    // }\n    // {\n    //   // Expandion -> then Any ASTReduction inside the expanded Macro --> need to Expand first\n    //   // ast = newAst\n\n    //   // let message = ''\n    //   // let isNormal = false\n\n    //   // setBoxState({\n    //   //   ...state,\n    //   //   history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal } ]\n    //   // })\n    //   // return\n    // }\n    // {\n    //   // Expansion -> then Any ASTReduction completely outside of Macro --> skip the Expansion and do the next thing instead\n    //   // ast = newevaluator.perform()\n    //   // const p = parent as AST\n    //   // const ts = treeSide as String\n    //   // (p as any)[ts as any] = M\n    //   // // parent should be not-null\n    //   // // because if there was a Macro which we were able to Expand\n    //   // // and then there has been found Redex which is not part of the newly expanded sub-tree\n    //   // // the new Redex simply has to be in different part of the tree --> which means - M (original Macro) is not the root\n\n    //   // let message = ''\n    //   // let isNormal = false\n\n    //   // setBoxState({\n    //   //   ...state,\n    //   //   history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal } ]\n    //   // })\n    //   // return\n    // }\n  }\n\n  onStep () : void {\n    // console.log('DOIN ONE STEP')\n    const { state, setBoxState } = this.props\n    const { strategy, SDE, history } = state\n\n    // this is gonna change - Simplified Evaluation won't be strategy - but Strategy Modifier\n    if (SDE) {\n      this.onSimplifiedStep()\n      return\n    }\n\n    const stepRecord = history[history.length - 1]\n    const { isNormalForm, step } = stepRecord\n    let { ast, lastReduction } = stepRecord\n    ast = ast.clone()\n\n  \n    if (isNormalForm) {\n      return\n    }\n\n    let evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(ast)\n    lastReduction = evaluator.nextReduction\n  \n    if (evaluator.nextReduction instanceof None) {\n      const etaEvaluator : Evaluator = new OptimizeEvaluator(ast)\n\n      if (etaEvaluator.nextReduction instanceof None) {\n        stepRecord.isNormalForm = true\n        stepRecord.message.message = 'Expression is in normal form.'\n        \n        setBoxState({\n          ...state,\n        })\n        \n        reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n  \n        return\n      }\n\n      evaluator = etaEvaluator\n      lastReduction = etaEvaluator.nextReduction\n    }\n  \n    ast = evaluator.perform()\n\n    let message : StepMessage = { validity : StepValidity.CORRECT, userInput : '', message : '' }\n    let isNormal = false\n\n    {\n      const astCopy : AST = ast.clone()\n      const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n      \n      if (evaluator.nextReduction instanceof None) {\n        const etaEvaluator : Evaluator = new OptimizeEvaluator(astCopy)\n\n        if (etaEvaluator.nextReduction instanceof None) {\n          isNormal = true\n          message.message = 'Expression is in normal form.'\n          \n          reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n        }\n      }\n    }\n\n    // ANCHOR: #0023\n    // NOTE: This is completely crazy - it doesn't make any sense\n    // TODO: Investigate more - and fix the functionality\n    // it probably should check if the current AST Root is a Macro and next Reduction is Expansion of exactly this AST\n    // then it can say - it is in the Normal Form - if some settings enables it - not by default though\n    //\n    // if (ast instanceof Macro || ast instanceof ChurchNumeral) {\n    //   console.log('CURRENT IS MACRO OR NUMBER')\n\n    //   stepRecord.isNormalForm = true\n    //   stepRecord.message = 'Expression is in normal form.'\n\n    //   reportEvent('Evaluation Step', 'Step Normal Form Reached with Number or Macro', ast.toString())\n    // }\n  \n    setBoxState({\n      ...state,\n      history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal, exerciseStep : false } ],\n\n    })\n\n    reportEvent('Evaluation Step', 'Step', ast.toString())\n  }\n\n  onExecute () : void {\n    const { state, setBoxState } = this.props\n    const { isRunning, SDE } = state\n\n    if (isRunning) {\n      this.onStop()\n    }\n    else {\n      const { timeout, history } = state\n      const stepRecord = history[history.length - 1]\n  \n      if (stepRecord.isNormalForm) {\n        return\n      }\n      \n      const { ast, step, lastReduction, isNormalForm } = stepRecord\n      let msg : StepMessage = { validity : StepValidity.CORRECT, userInput : '', message : 'Skipping some steps...' }\n      history.push(history[history.length - 1])\n      history[history.length - 2] = { ast : ast.clone(), step, lastReduction, message : msg, isNormalForm, exerciseStep : false }\n\n      if (SDE) {\n        setBoxState({\n          ...state,\n          isRunning : true,\n          timeoutID : window.setTimeout(this.onSimplifiedRun, timeout),\n        })\n      }\n      else {\n        setBoxState({\n          ...state,\n          isRunning : true,\n          timeoutID : window.setTimeout(this.onRun, timeout),\n        })\n      }\n\n      \n\n      reportEvent('Execution', 'Run Evaluation', ast.toString())\n    }\n  }\n\n  onSimplifiedRun () : void {\n    const { state, setBoxState } = this.props\n    const { strategy, macrotable } = state\n    let { history, isRunning, breakpoints, timeoutID, timeout } = state\n    const stepRecord : StepRecord = history[history.length - 1]\n    const { isNormalForm, step } = stepRecord\n    let { lastReduction } = stepRecord\n\n    if ( ! isRunning) {\n      return\n    }\n\n    if (isNormalForm) {\n      setBoxState({\n        ...state,\n        isRunning : false,\n        timeoutID : undefined,\n      })\n  \n      return\n    }\n\n    let { ast } = stepRecord\n    const newast : AST = ast.clone()\n    const [nextReduction, evaluateReduction] : [ASTReduction, (ast : AST) => AST] = findSimplifiedReduction(newast, strategy, macrotable)\n\n/////////////////////////////////////////////////////////////////////////////////////////\n    // const normal : Evaluator = new (strategyToEvaluator(strategy) as any)(ast)\n    lastReduction = nextReduction\n    \n    if (nextReduction instanceof None) {\n      // TODO: consider immutability\n      history.pop()\n      history.push({\n        ast,\n        lastReduction : stepRecord.lastReduction,\n        step,\n        message : { validity : StepValidity.CORRECT, userInput : '', message : 'Expression is in normal form.' },\n        isNormalForm : true,\n        exerciseStep : false,\n      })\n  \n      setBoxState({\n        ...state,\n        isRunning : false,\n        timeoutID : undefined,\n      })\n  \n      return\n    }\n\n    const arityBreakpoint : Breakpoint | undefined = breakpoints.find((brk : Breakpoint) => brk.type === ASTReductionType.GAMA && ! brk.broken.has((nextReduction as MacroBeta).applications[0]))\n    if (nextReduction instanceof MacroBeta && nextReduction.arity !== nextReduction.applications.length && arityBreakpoint === undefined) {\n      stepRecord.message.message = `Macro ${tryMacroContraction(nextReduction.applications[0].left, macrotable)} is given too few arguments.`\n    \n      // completely same code as in breakpoint section -- TODO: refactor and unify pls\n      window.clearTimeout(timeoutID)\n      reportEvent('Evaluation Run Ended', 'Breakpoint was reached', ast.toString())\n\n      breakpoints.push({ type : ASTReductionType.GAMA, context : nextReduction.applications[0], broken : new Set([ nextReduction.applications[0] ]) })\n\n      setBoxState({\n        ...state,\n        breakpoints,\n        isRunning : false,\n        timeoutID,\n      })\n\n      return\n    }\n  \n    // TODO: maybe refactor a little\n    const breakpoint : Breakpoint | undefined = breakpoints.find(\n      (breakpoint : Breakpoint) =>\n        this.shouldBreak(breakpoint, nextReduction)\n    )\n\n    if (breakpoint !== undefined) {\n      // TODO: consider immutability\n      if (nextReduction instanceof Expansion) {\n        breakpoint.broken.add(nextReduction.target)\n      }\n      if (nextReduction instanceof Beta && nextReduction.redex.left instanceof Lambda) {\n        breakpoint.broken.add(nextReduction.redex.left.argument)\n      }\n\n      window.clearTimeout(timeoutID)\n      reportEvent('Evaluation Run Ended', 'Breakpoint was reached', ast.toString())\n\n\n      setBoxState({\n        ...state,\n        isRunning : false,\n        timeoutID,\n      })\n\n      return\n    }\n  \n    ast = evaluateReduction(newast)\n\n    history[history.length - 1] = { ast, lastReduction, step : step + 1, message : { validity : StepValidity.CORRECT, userInput : '', message : '' }, isNormalForm, exerciseStep : false }\n\n    // NOTE: Same thing as #0023\n    // if (ast instanceof Macro || ast instanceof ChurchNumeral) {\n    //   history[history.length - 1] = { ast, lastReduction, step : step + 1, message : 'Expression is in normal form.', isNormalForm : true }\n\n    //   reportEvent('Evaluation Run Ended', 'Step Normal Form Reached with Number or Macro', ast.toString())\n    // }\n    \n    setBoxState({\n      ...state,\n      timeoutID : window.setTimeout(this.onSimplifiedRun, timeout)\n    })\n  }\n\n  onRun () : void {\n    const { state, setBoxState } = this.props\n    const { strategy } = state\n    let { history, isRunning, breakpoints, timeoutID, timeout } = state\n    const stepRecord : StepRecord = history[history.length - 1]\n    const { isNormalForm, step } = stepRecord\n    let { lastReduction } = stepRecord\n\n    if ( ! isRunning) {\n      return\n    }\n    \n    if (isNormalForm) {\n      setBoxState({\n        ...state,\n        isRunning : false,\n        timeoutID : undefined,\n      })\n  \n      return\n    }\n  \n    let { ast } = stepRecord\n    const normal : Evaluator = new (strategyToEvaluator(strategy) as any)(ast)\n    lastReduction = normal.nextReduction\n    \n    if (normal.nextReduction instanceof None) {\n      // TODO: consider immutability\n      history.pop()\n      history.push({\n        ast,\n        lastReduction : stepRecord.lastReduction,\n        step,\n        message : { validity : StepValidity.CORRECT, userInput : '', message : 'Expression is in normal form.' }, \n        isNormalForm : true,\n        exerciseStep : false,\n      })\n  \n      setBoxState({\n        ...state,\n        isRunning : false,\n        timeoutID : undefined,\n      })\n  \n      return\n    }\n  \n    // TODO: maybe refactor a little\n    const breakpoint : Breakpoint | undefined = breakpoints.find(\n      (breakpoint : Breakpoint) =>\n        this.shouldBreak(breakpoint, normal.nextReduction)\n    )\n\n    if (breakpoint !== undefined) {\n      // TODO: consider immutability\n      if (normal.nextReduction instanceof Expansion) {\n        breakpoint.broken.add(normal.nextReduction.target)\n      }\n      if (normal.nextReduction instanceof Beta && normal.nextReduction.redex.left instanceof Lambda) {\n        breakpoint.broken.add(normal.nextReduction.redex.left.argument)\n      }\n\n      window.clearTimeout(timeoutID)\n      reportEvent('Evaluation Run Ended', 'Breakpoint was reached', ast.toString())\n\n\n      setBoxState({\n        ...state,\n        isRunning : false,\n        timeoutID,\n      })\n\n      return\n    }\n  \n    ast = normal.perform()\n\n    history[history.length - 1] = { ast, lastReduction, step : step + 1, message : { validity : StepValidity.CORRECT, userInput : '', message : '' }, isNormalForm, exerciseStep : false }\n\n    // NOTE: Same thing as #0023\n    // if (ast instanceof Macro || ast instanceof ChurchNumeral) {\n    //   history[history.length - 1] = { ast, lastReduction, step : step + 1, message : 'Expression is in normal form.', isNormalForm : true }\n\n    //   reportEvent('Evaluation Run Ended', 'Step Normal Form Reached with Number or Macro', ast.toString())\n    // }\n    \n    setBoxState({\n      ...state,\n      timeoutID : window.setTimeout(this.onRun, timeout)\n    })\n  }\n\n  onStop () : void {\n    const { state, setBoxState } = this.props\n    const { timeoutID } = state\n  \n    window.clearTimeout(timeoutID)\n  \n    setBoxState({\n      ...state,\n      isRunning : false,\n      timeoutID : undefined\n    })\n  }\n\n  // TODO: breakpointy se pak jeste musi predelat\n  // TODO: don't forget on GAMA refactor\n  shouldBreak (breakpoint : Breakpoint, reduction : ASTReduction) : boolean {\n    // if (reduction.type === breakpoint.type\n    //     && reduction instanceof Beta && breakpoint.context instanceof Lambda\n    //     && reduction.target.identifier === breakpoint.context.body.identifier\n    //   ) {\n    //     return true\n    // }\n    if (reduction.type === breakpoint.type\n        && reduction instanceof Beta && breakpoint.context instanceof Variable\n        && reduction.redex.left instanceof Lambda\n        && reduction.redex.left.argument.identifier === breakpoint.context.identifier\n        && ! breakpoint.broken.has(reduction.redex.left.argument)\n    ) {\n      return true\n    }\n\n    if (reduction.type === breakpoint.type\n        && reduction instanceof Expansion && breakpoint.context instanceof ChurchNumeral\n        && reduction.target.identifier === breakpoint.context.identifier\n        && ! breakpoint.broken.has(reduction.target)\n    ) {\n      return true\n    }\n    if (reduction.type === breakpoint.type\n        && reduction instanceof Expansion && breakpoint.context instanceof Macro\n        && reduction.target.identifier === breakpoint.context.identifier\n        && ! breakpoint.broken.has(reduction.target)\n    ) {\n      return true\n    }\n  \n    return false\n  }\n\n}","import React from 'react'\nimport { MacroMap, builtinMacros } from '@lambdulus/core'\n\nimport './styles/MacroList.css'\n\n\nexport interface MacroProperties {\n  macroTable : MacroMap\n}\n\nexport default function MacroList (props : MacroProperties) : JSX.Element {\n  const { macroTable } = props\n\n  return (\n    <div className='macroSpace'>\n      <p>Built-in Macros:</p>\n      <ul className='UL'>\n        { Object.entries(builtinMacros).map(([macroName, macroExpression]) =>\n          <span key={ macroName }>\n            <li className='LI dense-LI'>\n              <span className='macro-definition'>\n                <i className='macro-name'>{ macroName }</i> := { macroExpression }\n              </span>\n            </li>\n          </span>\n        ) }\n      </ul>\n\n      <p>User-defined Macros:</p>\n      <ul className='UL'>\n        { Object.entries(macroTable).map(([macroName, macroExpression]) =>\n          <span key={ macroName }>\n            <li className='LI dense-LI'>\n              <span className='macro-definition'>\n                <i className='macro-name'>{ macroName }</i> := { macroExpression }\n              </span>\n            </li>\n          </span>\n        ) }\n      </ul>\n    </div>\n  )\n}","import React, { PureComponent } from 'react'\n\nimport {\n  AST,\n  ASTReduction,\n  None,\n  Token,\n  tokenize,\n  parse,\n  OptimizeEvaluator,\n  MacroMap,\n} from \"@lambdulus/core\"\n\nimport './styles/EvaluatorBox.css'\n\nimport { BoxType } from '../Types'\n\nimport { TreeComparator } from './TreeComparator'\nimport InactiveEvaluator from './InactiveExpression'\nimport Expression from './Expression'\nimport { PromptPlaceholder, UntypedLambdaState, Evaluator, StepRecord, Breakpoint, UntypedLambdaType, UntypedLambdaExpressionState, StepMessage, StepValidity } from './Types'\nimport { reportEvent } from '../misc'\nimport { strategyToEvaluator, findSimplifiedReduction, MacroBeta, toMacroMap, tryMacroContraction } from './AppTypes'\n\n\nexport interface EvaluationProperties {\n  state : UntypedLambdaExpressionState\n  isActive : boolean\n  isFocused : boolean\n  darkmode : boolean\n\n  setBoxState (state : UntypedLambdaExpressionState) : void\n  addBox (box : UntypedLambdaState) : void\n}\n\nexport default class ExerciseBox extends PureComponent<EvaluationProperties> {\n  constructor (props : EvaluationProperties) {\n    super(props)\n\n    this.onContent = this.onContent.bind(this)\n    this.onSubmitExpression = this.onSubmitExpression.bind(this)\n    this.parseExpression = this.parseExpression.bind(this)\n    this.onEnter = this.onEnter.bind(this)\n    this.onExerciseStep = this.onExerciseStep.bind(this)\n    this.onSimplifiedExerciseStep = this.onSimplifiedExerciseStep.bind(this)\n    this.onStep = this.onStep.bind(this)\n    this.onSimplifiedStep = this.onSimplifiedStep.bind(this)\n    this.onExecute = this.onExecute.bind(this)\n    this.onRun = this.onRun.bind(this)\n    this.onStop = this.onStop.bind(this)\n    this.shouldBreak = this.shouldBreak.bind(this)\n    this.createBoxFrom = this.createBoxFrom.bind(this)\n  }\n\n  render () : JSX.Element {\n    const { state, isActive, addBox, darkmode } : EvaluationProperties = this.props\n    const {\n      minimized,\n      history,\n      breakpoints,\n      editor,\n      SDE,\n      macrotable,\n    } : UntypedLambdaExpressionState = state\n\n    let className : string = 'box boxEval boxExercise'\n    const { isNormalForm } = history.length ? history[history.length - 1] : { isNormalForm : false }\n\n    // TODO: Maybe I will take this out\n    // Frontend may take care of that\n    if (minimized) {\n      return (\n        <InactiveEvaluator\n          className={ className }\n          breakpoints={ breakpoints }\n          history={ history }\n          strategy={ this.props.state.strategy }\n          SDE={ SDE }\n          macrotable={ macrotable }\n          \n          createBoxFrom={ this.createBoxFrom }\n        />\n      )\n    }\n\n    return (\n      <Expression\n        className={ className }\n        isExercise={ true }\n        state={ state }\n        breakpoints={ breakpoints }\n        history={ history }\n        editor={ editor }\n        isNormalForm={ isNormalForm }\n        shouldShowDebugControls={ isActive }\n        darkmode={ darkmode }\n\n        createBoxFrom={ this.createBoxFrom }\n        setBoxState={ this.props.setBoxState }\n        onContent={ this.onContent }\n        onEnter={ this.onEnter }\n        onExecute={ this.onExecute }\n        addBox={ addBox }\n      />\n    )\n  }\n\n  createBoxFrom (stepRecord : StepRecord) : UntypedLambdaState {\n    const { state } : EvaluationProperties = this.props\n    const {\n      strategy,\n      SLI,\n      SDE,\n      expandStandalones,\n      macrotable,\n    } : UntypedLambdaExpressionState = state\n    const { ast } = stepRecord\n    const content = ast.toString()\n\n    return {\n      __key : Date.now().toString(),\n      type : BoxType.UNTYPED_LAMBDA,\n      subtype : UntypedLambdaType.EMPTY,\n      title : `Copy of ${state.title}`,\n      minimized : false,\n      settingsOpen : false,\n      expression : \"\",\n      ast : null,\n      history : [],\n      isRunning : false,\n      breakpoints : [],\n      timeoutID : undefined,\n      timeout : 10,\n      strategy,\n      SDE,\n      SLI,\n      expandStandalones,\n      macrolistOpen : false,\n      macrotable : { }, // ...macrotable, ...this.props.macroContext.macrotable\n      editor : {\n        placeholder : PromptPlaceholder.EVAL_MODE,\n        content : Object.entries(macrotable).map(([name, definition] : [string, string]) => name + ' := ' + definition + ' ;\\n').join('') + content,\n        syntaxError : null,\n      }\n    }\n  }\n\n  onContent (content : string) : void {\n    const { state, setBoxState } = this.props\n\n    setBoxState({\n      ...state,\n      editor : {\n        ...state.editor,\n        content,\n        syntaxError : null,\n      }\n    })\n  }\n\n  onEnter () : void {\n    const { editor : { content } } = this.props.state\n\n    if (content === '') {\n      this.onStep()\n    }\n\n    this.onExerciseStep()\n  }\n\n  onSubmitExpression () : void {\n    const { state, setBoxState } = this.props\n    const {\n      strategy,\n      editor : { content },\n      macrotable,\n    } = state\n\n    try {\n      // const definitions : Array<string> = content.split(';')\n      // const expression : string = definitions.pop() || \"\"\n      // const macromap : MacroMap = toMacroMap(definitions, SLI)\n      // const newMacrotable : MacroMap = { ...macrotable, ...macromap } // the local macromap has a higher priority\n      \n      const ast : AST = this.parseExpression(content, macrotable)\n\n      let message : StepMessage = { validity : StepValidity.CORRECT, userInput : content, message : '' }\n      let isNormal = false\n\n      const astCopy : AST = ast.clone()\n      const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n      \n      if (evaluator.nextReduction instanceof None) {\n        isNormal = true\n        message.message = 'Expression is in normal form.'\n        \n        reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n      }\n\n      setBoxState({\n        ...state,\n        ast,\n        expression : content,\n        history : [ {\n          ast : ast.clone(),\n          lastReduction : new None(),\n          step : 0,\n          message,\n          isNormalForm : isNormal,\n          exerciseStep : true,\n        } ],\n        editor : {\n          content : '',\n          placeholder : PromptPlaceholder.EVAL_MODE,\n          syntaxError : null,\n        }\n      })\n\n      reportEvent('Submit Expression', 'submit valid', content)\n    } catch (exception) {\n      let errorMessage : string = \"Something is wrong with your expression. Please inspect it closely.\"\n      console.error((exception as Error).toString())\n\n      if (content.match(/:=/g)?.length !== content.match(/;/g)?.length) {\n        errorMessage = \"Did you forget to write a semicolon after the Macro definition?\"\n      }\n      if (content.match(/\\s*;\\s*$/g)) {\n        errorMessage = \"There's a semicolon at the end.\"\n      }\n      \n      setBoxState({\n        ...state,\n        editor : {\n          ...state.editor,\n          syntaxError : Error(errorMessage),\n        }\n      })\n\n      reportEvent('Submit Expression', 'submit invalid', content)\n    }\n  }\n\n  onSimplifiedExerciseStep () {\n    const { state, setBoxState } = this.props\n    const { strategy, history, editor : { content }, macrotable, SLI } = state\n\n    try {\n      const definitions : Array<string> = content.split(';')\n      const expression : string = definitions.pop() || \"\"\n      const macromap : MacroMap = toMacroMap(definitions, SLI)\n      const newMacrotable : MacroMap = { ...macrotable, ...macromap } // the local macromap has a higher priority\n      \n\n      const userAst : AST = this.parseExpression(expression, newMacrotable)\n      const stepRecord : StepRecord = history[history.length - 1]\n      const { isNormalForm, step } = stepRecord\n      let { ast, lastReduction } = stepRecord\n      ast = ast.clone()\n\n      if (isNormalForm) {\n        // TODO: do something about it\n        // say user - there are no more steps and it is in normal form        \n        // TODO: consider immutability\n        stepRecord.message.message = 'No more steps available. Expression is in normal form.'\n\n        setBoxState({\n          ...state,\n        })\n\n        reportEvent('Exercise Step', 'Step Already in normal form', content)\n\n        return\n      }\n    \n      const newast : AST = ast.clone()\n      let [nextReduction, evaluateReduction] : [ASTReduction, (ast : AST) => AST] = findSimplifiedReduction(newast, strategy, macrotable)\n      // const normal : Evaluator = new (strategyToEvaluator(strategy) as any)(ast)\n      // lastReduction = normal.nextReduction\n    \n      if (nextReduction instanceof None) {\n        const etaEvaluator : Evaluator = new OptimizeEvaluator(newast)\n\n        if (etaEvaluator.nextReduction instanceof None) {\n          // TODO: refactor PLS - update history\n          // TODO: say user it is in normal form and they are mistaken\n          stepRecord.isNormalForm = true\n          stepRecord.message.message = 'Expression is already in normal form.'\n          \n          setBoxState({\n            ...state,\n          })\n  \n          reportEvent('Simplified Exercise Step', 'Step Already in Normal Form', content)\n          \n          return\n        }\n\n        ast = etaEvaluator.perform()\n        // console.log(\"next step ale dala se udelat eta\", ast.toString(), userAst.toString())\n        lastReduction = etaEvaluator.nextReduction\n      }\n      else {\n        ast = evaluateReduction(newast)\n      }\n\n      let isNormal = false\n\n      {\n\n        const astCopy : AST = ast.clone()\n        const [nextReduction] : [ASTReduction, (ast : AST) => AST] = findSimplifiedReduction(astCopy, strategy, macrotable)\n        // const astCopy : AST = ast.clone()\n        // const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n        \n        if (nextReduction instanceof None) {\n          const etaEvaluator : Evaluator = new OptimizeEvaluator(astCopy)\n\n          if (etaEvaluator.nextReduction instanceof None) {\n            isNormal = true\n            reportEvent('Simplified Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n          }\n        }\n      }\n    \n      let message : StepMessage = { validity : StepValidity.CORRECT, userInput : content, message : '' }\n      const comparator : TreeComparator = new TreeComparator([ userAst, ast ], [ newMacrotable, macrotable ])\n\n      if (comparator.equals) {\n        ast = userAst\n        message.message = 'Correct.'\n\n        reportEvent('Exercise Step', 'Valid Step', content)\n      }\n      else {\n        // TODO: say user it was incorrect\n        // TODO: na to se pouzije uvnitr EvaluatorState prop messages nebo tak neco\n        // console.log('Incorrect step')\n        message.message = `Incorrect step. ${content}`\n        message.validity = StepValidity.INCORRECT\n\n        reportEvent('Exercise Step', 'Invalid Step', content)\n      }\n\n      setBoxState({\n        ...state,\n        history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal, exerciseStep : true } ],\n        editor : {\n          ...state.editor,\n          content : Object.entries(newMacrotable).map(([name, definition] : [string, string]) => name + ' := ' + definition + ' ;\\n').join('') + ast.toString(),\n          placeholder : PromptPlaceholder.VALIDATE_MODE,\n          syntaxError : null,\n        }\n      })\n    } catch (exception) {\n      // TODO: print syntax error\n      // TODO: do it localy - no missuse of onSubmit\n\n      // TODO: print syntax error\n\n      reportEvent('Exercise Step', 'Syntax error in Step', content)\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////////////////////\n  }\n\n  onExerciseStep () {\n    // console.log('EXERCISE STEP')\n    const { state, setBoxState } = this.props\n    const { strategy, history, editor : { content }, SDE, macrotable, SLI } = state\n    \n    if (SDE === true) {\n      this.onSimplifiedExerciseStep()\n      return\n    }\n\n\n    try {\n      const definitions : Array<string> = content.split(';')\n      const expression : string = definitions.pop() || \"\"\n      const macromap : MacroMap = toMacroMap(definitions, SLI)\n      const newMacrotable : MacroMap = { ...macrotable, ...macromap } // the local macromap has a higher priority\n      \n\n      const userAst : AST = this.parseExpression(expression, newMacrotable)\n      // HERE\n      const stepRecord : StepRecord = history[history.length - 1]\n      const { isNormalForm, step } = stepRecord\n      let { ast, lastReduction } = stepRecord\n      ast = ast.clone()\n\n      if (isNormalForm) {\n        // TODO: do something about it\n        // say user - there are no more steps and it is in normal form        \n        // TODO: consider immutability\n        stepRecord.message.message = 'No more steps available. Expression is in normal form.'\n\n        setBoxState({\n          ...state,\n        })\n\n        reportEvent('Exercise Step', 'Step Already in normal form', content)\n\n        return\n      }\n    \n      let evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(ast)\n      lastReduction = evaluator.nextReduction\n    \n      if (evaluator.nextReduction instanceof None) {\n        const etaEvaluator : Evaluator = new OptimizeEvaluator(ast)\n\n        if (etaEvaluator.nextReduction instanceof None) {\n          // TODO: refactor PLS - update history\n          // TODO: say user it is in normal form and they are mistaken\n          stepRecord.isNormalForm = true\n          stepRecord.message.message = 'Expression is already in normal form.'\n          \n          setBoxState({\n            ...state,\n          })\n  \n          reportEvent('Exercise Step', 'Step Already in Normal Form', content)\n          \n          return\n        }\n\n        evaluator = etaEvaluator\n        lastReduction = etaEvaluator.nextReduction\n\n      }\n    \n      ast = evaluator.perform()\n\n      let isNormal = false\n\n      {\n        const astCopy : AST = ast.clone()\n        const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n        \n        if (evaluator.nextReduction instanceof None) {\n          const etaEvaluator : Evaluator = new OptimizeEvaluator(astCopy)\n\n          if (etaEvaluator.nextReduction instanceof None) {\n            isNormal = true\n\n            reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n          }\n        }\n      }\n    \n      let message : StepMessage = { validity : StepValidity.CORRECT, userInput : content, message : '' }\n      const comparator : TreeComparator = new TreeComparator([ userAst, ast ], [ newMacrotable, macrotable ])\n\n      if (comparator.equals) {\n        ast = userAst\n        message.message = 'Correct.'\n\n        reportEvent('Exercise Step', 'Valid Step', content)\n      }\n      else {\n        // TODO: say user it was incorrect\n        // TODO: na to se pouzije uvnitr EvaluatorState prop messages nebo tak neco\n        // console.log('Incorrect step')\n        message.message = `Incorrect step. ${content}`\n        message.validity = StepValidity.INCORRECT\n\n        reportEvent('Exercise Step', 'Invalid Step', content)\n      }\n\n      setBoxState({\n        ...state,\n        history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal, exerciseStep : true } ],\n        editor : {\n          ...state.editor,\n          content : Object.entries(newMacrotable).map(([name, definition] : [string, string]) => name + ' := ' + definition + ' ;\\n').join('') + ast.toString(),\n          placeholder : PromptPlaceholder.VALIDATE_MODE,\n          syntaxError : null,\n        }\n      })\n    } catch (exception) {\n      // TODO: print syntax error\n      // TODO: do it localy - no missuse of onSubmit\n\n      // TODO: print syntax error\n\n      reportEvent('Exercise Step', 'Syntax error in Step', content)\n    }\n  }\n\n  onSimplifiedStep () : void {\n    // console.log(\"DOIN ONE STEP       _______     SIMPLIFIED\")\n    // console.log('simplified step')\n\n\n    const { state, setBoxState } = this.props\n    const { strategy, history, editor : { content }, macrotable } = state\n    const stepRecord = history[history.length - 1]\n    const { isNormalForm, step } = stepRecord\n    const ast = stepRecord.ast.clone()\n    let newast = ast\n\n    if (isNormalForm) {\n      return\n    }\n\n    // console.log('looooooooooooooooooooooooooooking')\n\n    //                                                    fix this part please\n    let [nextReduction, evaluateReduction] : [ASTReduction, (ast : AST) => AST] = findSimplifiedReduction(ast, strategy, macrotable)\n    // console.log('BACK TO THE WORLD HERE')\n    \n    let message : StepMessage = { validity : StepValidity.CORRECT, userInput : content, message : '' }\n    let isNowNormalForm = false\n\n    // console.log(nextReduction)\n\n    if (nextReduction instanceof MacroBeta) {\n      // console.log(\"YES MACRO BETA HERE\")\n      // z macrobeta si vytahnu aritu makra\n      const arity : number = nextReduction.arity\n\n      // a zkontroluju jestli velikost pole odpovida arite\n      if (nextReduction.applications.length !== arity) {\n        // pokud arita nesedi - je vetsi nez delka pole aplikaci -->\n        // --> musim vyhlasit warning a rict, ze tenhle krok neni uplne gooda\n        // console.log(\"ARITY IS WRONG - probably too few arguments\")\n        stepRecord.message.message = `Macro ${tryMacroContraction(nextReduction.applications[0].left, macrotable)} is given too few arguments.`\n\n        newast = evaluateReduction(newast)\n\n        // this.setState({\n        //   ...state,\n        // })\n        // return\n      }\n      else {\n        // this is what happens when ::single-step\n        //\n        newast = evaluateReduction(newast)\n        // debugger\n\n        // if we are not ::single-step --> findSimplifiedReduction won't return MacroBeta -- instead\n        // it will return the first redex --> first beta reduction in the list and then it's not macro reduction problem anymore\n        // so next consecutive redex search will just find pretty normal situation as it probably should\n      }\n    }\n    else if (nextReduction instanceof None) {\n      const etaEvaluator : Evaluator = new OptimizeEvaluator(ast)\n\n      if (etaEvaluator.nextReduction instanceof None) {\n        stepRecord.isNormalForm = true\n        stepRecord.message.message = 'Expression is in normal form.'\n        setBoxState({\n          ...state,\n        })\n        return  \n      }\n\n      newast = etaEvaluator.perform()\n      nextReduction = etaEvaluator.nextReduction\n    }\n    else {\n      newast = evaluateReduction(newast)\n    }\n\n\n    {\n      // console.log('copak se tohle vubec neprovadi????????????????')\n      const astCopy : AST = newast.clone()\n      const [nextReduction] : [ASTReduction, (ast : AST) => AST] = findSimplifiedReduction(astCopy, strategy, macrotable)\n      // const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n      \n      if (nextReduction instanceof None) {\n        const etaEvaluator : Evaluator = new OptimizeEvaluator(astCopy)\n\n        if (etaEvaluator.nextReduction instanceof None) {\n          isNowNormalForm = true\n          message.message = 'Expression is in normal form.'\n          \n          reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n        }\n      }\n    }\n\n    setBoxState({\n      ...state,\n      editor : {\n        ...state.editor,\n        content : ast.toString(),\n      },\n      history : [ ...history, { ast : newast, lastReduction : nextReduction, step : step + 1, message, isNormalForm : isNowNormalForm, exerciseStep : true } ],\n    })\n\n    reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n    return\n    \n    // {\n    //   // None\n    //   // console.log(\"_________________________________ NONE\")\n    //   // stepRecord.isNormalForm = true\n    //   // stepRecord.message = 'Expression is in normal form.'\n      \n    //   // setBoxState({\n    //   //   ...state,\n    //   // })\n      \n    //   // reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n\n    //   // return\n    // }\n    // {\n    //   // Expansion -> then None\n    //   // stepRecord.lastReduction = newreduction\n    //   // stepRecord.isNormalForm = true\n    //   // stepRecord.message = 'Expression is in normal form.'\n      \n    //   // setBoxState({\n    //   //   ...state,\n    //   // })\n      \n    //   // reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n\n    //   // return\n    // }\n    // {\n    //   // Expandion -> then Any ASTReduction inside the expanded Macro --> need to Expand first\n    //   // ast = newAst\n\n    //   // let message = ''\n    //   // let isNormal = false\n\n    //   // setBoxState({\n    //   //   ...state,\n    //   //   history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal } ]\n    //   // })\n    //   // return\n    // }\n    // {\n    //   // Expansion -> then Any ASTReduction completely outside of Macro --> skip the Expansion and do the next thing instead\n    //   // ast = newevaluator.perform()\n    //   // const p = parent as AST\n    //   // const ts = treeSide as String\n    //   // (p as any)[ts as any] = M\n    //   // // parent should be not-null\n    //   // // because if there was a Macro which we were able to Expand\n    //   // // and then there has been found Redex which is not part of the newly expanded sub-tree\n    //   // // the new Redex simply has to be in different part of the tree --> which means - M (original Macro) is not the root\n\n    //   // let message = ''\n    //   // let isNormal = false\n\n    //   // setBoxState({\n    //   //   ...state,\n    //   //   history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal } ]\n    //   // })\n    //   // return\n    // }\n  }\n\n  onStep () : void {\n    // console.log('DOIN ONE STEP')\n    const { state, setBoxState } = this.props\n    const { strategy, history, SDE } = state\n    const stepRecord = history[history.length - 1]\n    const { isNormalForm, step } = stepRecord\n    let { ast, lastReduction } = stepRecord\n    ast = ast.clone()\n  \n    if (isNormalForm) {\n      // console.log('normal form bro')\n      \n      return\n    }\n\n    if (SDE) {\n      this.onSimplifiedStep()\n      return\n    }\n\n    console.log('normal step')\n\n    let evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(ast)\n    lastReduction = evaluator.nextReduction\n  \n    if (evaluator.nextReduction instanceof None) {\n      const etaEvaluator : Evaluator = new OptimizeEvaluator(ast)\n\n      if (etaEvaluator.nextReduction instanceof None) {\n        // console.log('NEXT IS NONE')\n        stepRecord.isNormalForm = true\n        stepRecord.message.message = 'Expression is in normal form.'\n        \n        setBoxState({\n          ...state,\n        })\n        \n        reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n  \n        return\n      }\n\n      evaluator = etaEvaluator\n      lastReduction = etaEvaluator.nextReduction\n    }\n  \n    ast = evaluator.perform()\n\n    let message : StepMessage = { message : 'Evaluating One Step for You', validity : StepValidity.CORRECT, userInput : '' }\n    let isNormal = false\n\n    {\n      const astCopy : AST = ast.clone()\n      const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n      \n      if (evaluator.nextReduction instanceof None) {\n        const etaEvaluator : Evaluator = new OptimizeEvaluator(ast)\n\n        if (etaEvaluator.nextReduction instanceof None) {\n          isNormal = true\n          message.message = 'Expression is in normal form.'\n          \n          reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n        }\n      }\n    }\n\n    // ANCHOR: #0023\n    // NOTE: This is completely crazy - it doesn't make any sense\n    // TODO: Investigate more - and fix the functionality\n    // it probably should check if the current AST Root is a Macro and next Reduction is Expansion of exactly this AST\n    // then it can say - it is in the Normal Form - if some settings enables it - not by default though\n    //\n    // if (ast instanceof Macro || ast instanceof ChurchNumeral) {\n    //   console.log('CURRENT IS MACRO OR NUMBER')\n\n    //   stepRecord.isNormalForm = true\n    //   stepRecord.message = 'Expression is in normal form.'\n\n    //   reportEvent('Evaluation Step', 'Step Normal Form Reached with Number or Macro', ast.toString())\n    // }\n  \n    setBoxState({\n      ...state,\n      editor : {\n        ...state.editor,\n        content : ast.toString(),\n      },\n      history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal, exerciseStep : true } ],\n\n    })\n\n    reportEvent('Exercise Empty Evaluation Step', 'Step', ast.toString())\n  }\n\n  onExecute () : void {\n    // const { state, setBoxState } = this.props\n    // const { isRunning } = state\n\n    // // if (isExercise) {\n    // //   // TODO: exercises can not be run - some message to user???\n    // //   return\n    // // }\n\n    // if (isRunning) {\n    //   this.onStop()\n    // }\n    // else {\n    //   const { timeout, history } = state\n    //   const stepRecord = history[history.length - 1]\n  \n    //   if (stepRecord.isNormalForm) {\n    //     return\n    //   }\n      \n    //   const { ast, step, lastReduction, isNormalForm, message } = stepRecord\n    //   history.push(history[history.length - 1])\n    //   history[history.length - 2] = { ast : ast.clone(), step, lastReduction, message : 'Skipping some steps...', isNormalForm }\n\n    //   setBoxState({\n    //     ...state,\n    //     isRunning : true,\n    //     timeoutID : window.setTimeout(this.onRun, timeout),\n    //   })\n\n    //   reportEvent('Execution', 'Run Evaluation', ast.toString())\n    // }\n  }\n\n  onRun () : void {\n    // const { state, setBoxState } = this.props\n    // const { strategy } = state\n    // let { history, isRunning, breakpoints, timeoutID, timeout } = state\n    // const stepRecord : StepRecord = history[history.length - 1]\n    // const { isNormalForm, step } = stepRecord\n    // let { lastReduction } = stepRecord\n\n    // if ( ! isRunning) {\n    //   return\n    // }\n    \n    // if (isNormalForm) {\n    //   setBoxState({\n    //     ...state,\n    //     isRunning : false,\n    //     timeoutID : undefined,\n    //   })\n  \n    //   return\n    // }\n  \n    // let { ast } = stepRecord\n    // const normal : Evaluator = new (strategyToEvaluator(strategy) as any)(ast)\n    // lastReduction = normal.nextReduction\n    \n    // if (normal.nextReduction instanceof None) {\n    //   // TODO: consider immutability\n    //   history.pop()\n    //   history.push({\n    //     ast,\n    //     lastReduction : stepRecord.lastReduction,\n    //     step,\n    //     message : 'Expression is in normal form.',\n    //     isNormalForm : true\n    //   })\n  \n    //   setBoxState({\n    //     ...state,\n    //     isRunning : false,\n    //     timeoutID : undefined,\n    //   })\n  \n    //   return\n    // }\n  \n    // // TODO: maybe refactor a little\n    // const breakpoint : Breakpoint | undefined = breakpoints.find(\n    //   (breakpoint : Breakpoint) =>\n    //     this.shouldBreak(breakpoint, normal.nextReduction)\n    // )\n\n    // if (breakpoint !== undefined) {\n    //   // TODO: consider immutability\n    //   if (normal.nextReduction instanceof Expansion) {\n    //     breakpoint.broken.add(normal.nextReduction.target)\n    //   }\n    //   if (normal.nextReduction instanceof Beta && normal.nextReduction.redex.left instanceof Lambda) {\n    //     breakpoint.broken.add(normal.nextReduction.redex.left.argument)\n    //   }\n\n    //   window.clearTimeout(timeoutID)\n    //   reportEvent('Evaluation Run Ended', 'Breakpoint was reached', ast.toString())\n\n\n    //   setBoxState({\n    //     ...state,\n    //     isRunning : false,\n    //     timeoutID,\n    //   })\n\n    //   return\n    // }\n  \n    // ast = normal.perform()\n\n    // history[history.length - 1] = { ast, lastReduction, step : step + 1, message : '', isNormalForm }\n\n    // // NOTE: Same thing as #0023\n    // // if (ast instanceof Macro || ast instanceof ChurchNumeral) {\n    // //   history[history.length - 1] = { ast, lastReduction, step : step + 1, message : 'Expression is in normal form.', isNormalForm : true }\n\n    // //   reportEvent('Evaluation Run Ended', 'Step Normal Form Reached with Number or Macro', ast.toString())\n    // // }\n    \n    // setBoxState({\n    //   ...state,\n    //   timeoutID : window.setTimeout(this.onRun, timeout)\n    // })\n  }\n\n  onStop () : void {\n    // const { state, setBoxState } = this.props\n    // const { timeoutID } = state\n  \n    // window.clearTimeout(timeoutID)\n  \n    // setBoxState({\n    //   ...state,\n    //   isRunning : false,\n    //   timeoutID : undefined\n    // })\n  }\n\n  // TODO: breakpointy se pak jeste musi predelat\n  shouldBreak (breakpoint : Breakpoint, reduction : ASTReduction) : boolean {\n    // // if (reduction.type === breakpoint.type\n    // //     && reduction instanceof Beta && breakpoint.context instanceof Lambda\n    // //     && reduction.target.identifier === breakpoint.context.body.identifier\n    // //   ) {\n    // //     return true\n    // // }\n    // if (reduction.type === breakpoint.type\n    //     && reduction instanceof Beta && breakpoint.context instanceof Variable\n    //     && reduction.redex.left instanceof Lambda\n    //     && reduction.redex.left.argument.identifier === breakpoint.context.identifier\n    //     && ! breakpoint.broken.has(reduction.redex.left.argument)\n    // ) {\n    //   return true\n    // }\n\n    // if (reduction.type === breakpoint.type\n    //     && reduction instanceof Expansion && breakpoint.context instanceof ChurchNumeral\n    //     && reduction.target.identifier === breakpoint.context.identifier\n    //     && ! breakpoint.broken.has(reduction.target)\n    // ) {\n    //   return true\n    // }\n    // if (reduction.type === breakpoint.type\n    //     && reduction instanceof Expansion && breakpoint.context instanceof Macro\n    //     && reduction.target.identifier === breakpoint.context.identifier\n    //     && ! breakpoint.broken.has(reduction.target)\n    // ) {\n    //   return true\n    // }\n  \n    return false\n  }\n\n  // THROWS Exceptions\n  parseExpression (expression : string, macrotable : MacroMap) : AST {\n    console.log('parsing expression ', expression)\n    // const { macrotable } = this.props.macroContext\n    console.log('my macrotable ', macrotable)\n\n    const { SLI : singleLetterVars } = this.props.state\n\n    const tokens : Array<Token> = tokenize(expression, { lambdaLetters : ['λ'], singleLetterVars, macromap : macrotable })\n    const ast : AST = parse(tokens, macrotable) // macroTable\n\n    return ast\n  }\n}","import React, { ChangeEvent } from 'react'\nimport { UntypedLambdaSettings, EvaluationStrategy, SettingsEnabled } from './Types'\n\nimport './styles/Settings.css'\n\n// const { Switch, Radio } = require('pretty-checkbox-react')\n\n\ninterface Props {\n  settings : UntypedLambdaSettings\n  settingsEnabled : SettingsEnabled\n\n  change : (settings : UntypedLambdaSettings) => void\n}\n\nexport default function Settings (props : Props) : JSX.Element {\n  const { settings, change, settingsEnabled } : Props = props\n  const { SLI, expandStandalones, strategy, SDE } : UntypedLambdaSettings = settings\n  const { SLI : SLI_E, expandStandalones : expSt_E, strategy : strat_E } : SettingsEnabled = settingsEnabled\n\n\n  // this is just a dirty-quick implementation to get an unique identifier\n  const array = new Uint32Array(2)\n  window.crypto.getRandomValues(array)\n  const uniq : string = `${Date.now()}-${Math.random()}-${array[0]}-${array[1]}`\n\n  return (\n    <div className='untyped-lambda-box--settings'>\n      {/* <h3>Untyped Lambda Calculus</h3> */}\n\n      {\n        SLI_E ?\n          <span\n            className='untyped-lambda-settings-SLI'\n            title='Single Letters as Names without Spaces'>\n            <input\n              id={ `untyped-lambda-settings--SLI-${uniq}` }\n              type='checkbox'\n              checked={ SLI }\n              disabled={ false } // TODO: tohle bude rozhodne chtit prepsat\n              // shape=\"fill\"\n              \n              onChange={\n                (e : ChangeEvent<HTMLInputElement>) => // tady nejakej destructuring\n                  change({ ...settings, SLI : e.target.checked })\n              }\n            />\n            <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--SLI-${uniq}` }>\n              Single Letter Names\n            </label>\n          </span>\n        :\n          null\n      }\n\n      {\n        <span\n          className='untyped-lambda-settings-SDE'\n          title='Simplified Evaluation'>\n          <input\n            id={ `untyped-lambda-settings--SDE-${uniq}` }\n            type='checkbox'\n            checked={ SDE }\n            disabled={ false }\n            // shape=\"fill\"\n            \n            onChange={\n              (e : ChangeEvent<HTMLInputElement>) => // tady nejakej destructuring\n                change({ ...settings, SDE : e.target.checked })\n            }\n          />\n          <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--SDE-${uniq}` }>\n            Simplified Evaluation\n          </label>\n        </span>\n      }\n\n      {\n        expSt_E && false ? // hiding this out - I am not sure what this should be in the first place\n          <span\n            className='untyped-lambda-settings-expand'\n            title='Expand Numbers and Macros at the End'>\n            <input\n              id={ `untyped-lambda-settings--expand-${uniq}` }\n              type='checkbox'\n              checked={ expandStandalones }\n              disabled={ false } // TODO: tohle bude rozhodne chtit prepsat\n              // shape=\"fill\"\n              \n              onChange={\n                (e : ChangeEvent<HTMLInputElement>) => {\n                  // tady nejakej destructuring\n                  change({ ...settings, expandStandalones : e.target.checked })\n                }\n              }\n            />\n            <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--expand-${uniq}` }>\n              Expand Macros and Numbers at the End\n            </label>\n          </span>\n        :\n          null\n      }\n\n      {\n        strat_E ?\n          <div className='untyped-lambda-settings-strategies inlineblock'>\n            <p className='stratsLabel inlineblock'>Evaluation Strategies:</p>\n            {/* <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n              <input\n                id={ `untyped-lambda-settings--simplified-strategy-${uniq}` }\n                type='radio'\n                name={ `untyped-lambda-settings--strategy-${uniq}` }\n                // style=\"fill\"\n                checked={\n                  strategy === EvaluationStrategy.ABSTRACTION\n                }\n                \n                onChange={\n                  () => change({ ...settings, strategy : EvaluationStrategy.ABSTRACTION })\n                }\n              />\n              <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--simplified-strategy-${uniq}` }>\n                Simplified\n              </label>\n            </span> */}\n\n            <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n              <input\n                id={ `untyped-lambda-settings--normal-strategy-${uniq}` }\n                type='radio'\n                name={ `untyped-lambda-settings--strategy-${uniq}` }\n                // style=\"fill\"\n                checked={\n                  strategy === EvaluationStrategy.NORMAL\n                }\n\n                onChange={\n                  () => change({ ...settings, strategy : EvaluationStrategy.NORMAL })\n                }\n              />\n              <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--normal-strategy-${uniq}` }>\n                Normal\n              </label>\n            </span>\n\n            <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n              <input\n                id={ `untyped-lambda-settings--applicative-strategy-${uniq}` }\n                type='radio'\n                name={ `untyped-lambda-settings--strategy-${uniq}` }\n                // style=\"fill\"\n                checked={\n                  strategy === EvaluationStrategy.APPLICATIVE\n                }\n                \n                onChange={\n                  () => change({ ...settings, strategy : EvaluationStrategy.APPLICATIVE })\n                }\n              />\n              <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--applicative-strategy-${uniq}` }>\n                Applicative\n              </label>\n            </span>\n          </div>\n        :\n          null\n    }\n    </div>\n  )\n}","import React from 'react'\n\nimport Editor from '../components/Editor'\nimport { UntypedLambdaExpressionState } from './Types'\n\nimport './styles/EmptyExpression.css'\n\ninterface EmptyExpressionProps {\n  className : string\n  isActive : boolean\n  isMinimized : boolean\n  state : UntypedLambdaExpressionState\n  editor : {\n    placeholder : string\n    content : string\n    syntaxError : Error | null\n  }\n  darkmode : boolean\n\n  onContent (content : string) : void\n  onDebug () : void\n  onExercise () : void\n  setBoxState (box : UntypedLambdaExpressionState) : void\n}\n\n\nexport default function EmptyExpression(props : EmptyExpressionProps) : JSX.Element{\n  const { className, isActive, editor, isMinimized, darkmode /*, state  */ } = props\n  const {\n    placeholder,\n    content,\n    syntaxError,\n  } = editor\n  // const { SDE, strategy, SLI } = state\n\n  // this is just a dirty-quick implementation to get an unique identifier\n  const array = new Uint32Array(2)\n  window.crypto.getRandomValues(array)\n  // const uniq : string = `${Date.now()}-${Math.random()}-${array[0]}-${array[1]}`\n\n  // const makeActive = useContext(MakeActiveContext)\n  // const deleteBox = useContext(DeleteBox)\n\n  return (\n    <div\n      className={ `${className} ${isActive ? '' : ' inactiveBox'}` }\n    >\n      {\n        ! isMinimized ?\n          (\n            <div>\n              <Editor\n                placeholder={ placeholder } // data\n                content={ content } // data\n                syntaxError={ syntaxError } // data\n                submitOnEnter={ false } // data\n                shouldReplaceLambda={ true }\n                darkmode={ darkmode }\n\n                onContent={ props.onContent } // fn\n                onEnter={ () => void 0 } // fn\n                onCtrlEnter={ props.onDebug }\n                onShiftEnter={ props.onExercise }\n                onExecute={ () => void 0 } // fn\n              />\n\n              <div className='debug-controls'>\n                <button\n                  title='Debug this Expression in the Evaluator (Ctrl + Enter)'\n                  type=\"button\"\n                  className='open-as-debug btn'\n                  onClick={ props.onDebug }\n                >\n                  <span\n                    className='untyped-lambda--submit-expression--btn-label'\n                  >\n                    Debug\n                  </span>\n                </button>\n                \n                <button\n                  title='Exercise this Expression Yourself (Shift + Enter)'\n                  type=\"button\"\n                  className='open-as-exercise btn'\n                  onClick={ props.onExercise }\n                >\n                  <span className='untyped-lambda--submit-expression--btn-label'>Exercise</span>\n                </button>\n                \n              </div>\n            </div>\n          )\n          :\n          (\n            <div>\n              <p className='inactiveMessage'>\n                Collapsing Empty Expression Box. Click to activate this box.\n              </p>\n            </div>\n          )\n      }\n\n\n      {/* <div\n        className='untyped-lambda--pick-strategy untyped-lambda-settings-strategies inlineblock'\n        style={ { height: '2.5em' } }\n      >\n        <p className='stratsLabel inlineblock'>Strategy:</p>\n        <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n          <input\n            id={ `untyped-lambda-settings--normal-strategy-${uniq}` }\n            type='radio'\n            name={ `untyped-lambda-settings--strategy-${uniq}` }\n            // style=\"fill\"\n            checked={\n              strategy === EvaluationStrategy.NORMAL\n            }\n\n            onChange={\n              () => setBoxState({ ...state, strategy : EvaluationStrategy.NORMAL })\n            }\n          />\n          <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--normal-strategy-${uniq}` }>\n            Normal\n          </label>\n        </span>\n\n        <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n          <input\n            id={ `untyped-lambda-settings--applicative-strategy-${uniq}` }\n            type='radio'\n            name={ `untyped-lambda-settings--strategy-${uniq}` }\n            // style=\"fill\"\n            checked={\n              strategy === EvaluationStrategy.APPLICATIVE\n            }\n            \n            onChange={\n              () => setBoxState({ ...state, strategy : EvaluationStrategy.APPLICATIVE })\n            }\n          />\n          <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--applicative-strategy-${uniq}` }>\n            Applicative\n          </label>\n        </span>\n      </div> */}\n\n      {/* Here add SDE switch/checkbox */}\n      {/* {\n        <span\n          className='untyped-lambda-settings-SDE-'\n          title='Simplified Evaluation'>\n          <input\n            id={ `untyped-lambda-settings--SDE-${uniq}` }\n            type='checkbox'\n            checked={ SDE }\n            disabled={ false }\n            // shape=\"fill\"\n            \n            onChange={\n              (e : ChangeEvent<HTMLInputElement>) => // tady nejakej destructuring\n                setBoxState({ ...state, SDE : e.target.checked })\n            }\n          />\n          <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--SDE-${uniq}` }>\n            Simplified Evaluation\n          </label>\n        </span>\n      } */}\n\n      {/* <span\n        className='untyped-lambda-settings-SLI-'\n        title='Single Letters as Names without Spaces'>\n        <input\n          id={ `untyped-lambda-settings--SLI-${uniq}` }\n          type='checkbox'\n          checked={ SLI }\n          disabled={ false } // TODO: tohle bude rozhodne chtit prepsat\n          // shape=\"fill\"\n          \n          onChange={\n            (e : ChangeEvent<HTMLInputElement>) => // tady nejakej destructuring\n              setBoxState({ ...state, SLI : e.target.checked })\n          }\n        />\n        <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--SLI-${uniq}` }>\n          Single Letter Names\n        </label>\n      </span> */}\n  </div>\n  )\n}","import React, { PureComponent } from 'react'\n\nimport { BoxType } from '../Types'\nimport { UntypedLambdaState, UntypedLambdaType, UntypedLambdaSettings, PromptPlaceholder, StepMessage, StepValidity } from './Types'\nimport ExpressionBox from './ExpressionBox'\nimport MacroList from './MacroList'\nimport { GLOBAL_SETTINGS_ENABLER, strategyToEvaluator, findSimplifiedReduction, toMacroMap } from './AppTypes'\nimport ExerciseBox from './ExerciseBox'\nimport Settings from './Settings'\nimport EmptyExpression from './EmptyExpression'\nimport { reportEvent } from '../misc'\nimport { None, Evaluator, Token, tokenize, parse, AST, OptimizeEvaluator, MacroMap } from '@lambdulus/core'\n\n\ninterface Props {\n  state : UntypedLambdaState\n  isActive : boolean\n  isFocused : boolean\n  darkmode : boolean\n\n  setBoxState (state : UntypedLambdaState) : void\n  addBox (box : UntypedLambdaState) : void\n}\n\nexport default class UntypedLambdaBox extends PureComponent<Props> {\n  render () {\n    const { state, isActive, isFocused, setBoxState, addBox, darkmode } : Props = this.props\n    const { settingsOpen, subtype, macrolistOpen, SLI, expandStandalones, strategy, SDE, editor, minimized } : UntypedLambdaState = state\n\n\n    const renderBoxContent = () => {\n      switch (subtype) {\n        case UntypedLambdaType.EMPTY:\n          return (\n            <EmptyExpression\n              className='box boxEval'\n              isActive={ isActive }\n              isMinimized={ minimized }\n              editor={ editor }\n              state={ state }\n              onContent={(content : string) =>\n                setBoxState({\n                  ...state,\n                  editor : {\n                    ...state.editor,\n                    content,\n                    syntaxError : null,\n                  }\n                })\n              }\n              darkmode={ darkmode }\n              onDebug={ () => this.onSubmitExpression(UntypedLambdaType.ORDINARY) }\n              onExercise={ () => this.onSubmitExpression(UntypedLambdaType.EXERCISE) }\n              setBoxState={ setBoxState }\n            />\n          )\n  \n        case UntypedLambdaType.ORDINARY:\n          return (\n            <ExpressionBox\n              state={ state }\n              isActive={ isActive }\n              isFocused={ isFocused }\n              setBoxState={ setBoxState }\n              addBox={ addBox }\n              darkmode={ darkmode }\n            />\n          )\n        \n        case UntypedLambdaType.EXERCISE:\n          return (\n            <ExerciseBox\n              state={ state }\n              isActive={ isActive }\n              isFocused={ isFocused }\n              setBoxState={ setBoxState }\n              addBox={ addBox }\n              darkmode={ darkmode }\n            />\n          )\n      }\n    }\n\n    return (\n      <div\n        ref={ (elem : any) => {\n          // This is just temporary\n          // should be replaced with much finer logic\n          // like: store ref to the state and then scroll to the part of the Box which should be visible\n          // depending on the action user just did\n          // for now - it will do\n          if (elem !== null && isActive) {\n            const boundingRect = elem.getBoundingClientRect()\n            const viewportHeight : number = window.innerHeight\n            if (boundingRect.bottom > viewportHeight) {\n              elem.scrollIntoView(false)\n            }\n          }\n        } }\n      >\n        {\n          settingsOpen ?\n            <div className='box-settings'>\n              Settings:\n              <Settings\n                settings={ { type : BoxType.UNTYPED_LAMBDA, SLI, expandStandalones, strategy, SDE } }\n                settingsEnabled={ GLOBAL_SETTINGS_ENABLER }\n\n                change={ (settings : UntypedLambdaSettings) => {\n                  setBoxState({\n                    ...state,\n                    ...settings\n                  })\n                } }\n              />\n            </div>\n          :\n            null\n        }\n        {\n          macrolistOpen ?\n            <div className='untyped-lambda-box--macrolist'>\n              <MacroList macroTable={ state.macrotable }  />\n            </div>\n          :\n            null\n        }\n\n        <div>\n          { renderBoxContent() }\n        </div>\n\n      </div>\n    )\n  }\n\n  onSubmitExpression (subtype : UntypedLambdaType) : void {\n    const { state, setBoxState } = this.props\n    const {\n      editor : { content },\n      strategy,\n      SDE,\n      SLI,\n    } = state\n\n    try {\n      const definitions : Array<string> = content.split(';')\n      const expression : string = definitions.pop() || \"\"\n      const macromap : MacroMap = toMacroMap(definitions, SLI)\n\n      const ast : AST = this.parseExpression(expression, macromap)\n\n      let message : StepMessage = { validity : StepValidity.CORRECT, userInput : '', message : '' }\n      let isNormal = false\n\n      const astCopy : AST = ast.clone()\n\n      const nextReduction = (() => {\n        if (SDE) {\n          return findSimplifiedReduction(astCopy, strategy, macromap)[0]\n        }\n        else {\n          const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n          return evaluator.nextReduction\n        }\n      })()\n\n      \n      if (nextReduction instanceof None) {\n        const etaEvaluator : Evaluator = new OptimizeEvaluator(ast)\n\n        if (etaEvaluator.nextReduction instanceof None) {\n          isNormal = true\n          message.message = 'Expression is in normal form.'\n          reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n        }\n      }\n\n      setBoxState({\n        ...state,\n        settingsOpen : false,\n        ast,\n        subtype,\n        expression : content,\n        macrotable : macromap,\n        history : [ {\n          ast : ast.clone(),\n          lastReduction : new None(),\n          step : 0,\n          message,\n          isNormalForm : isNormal,\n          exerciseStep : false,\n        } ],\n        editor : {\n          content : content,\n          placeholder : PromptPlaceholder.EVAL_MODE,\n          syntaxError : null,\n        }\n      })\n\n      reportEvent('Submit Expression', 'submit valid', content)\n    } catch (exception) {\n      let errorMessage : string = \"Something is wrong with your expression. Please inspect it closely.\"\n      console.error((exception as Error).toString())\n\n      // if (errorMessage === \"Error\") {\n        if (content.match(/:=/g)?.length !== content.match(/;/g)?.length) {\n          errorMessage = \"Did you forget to write a semicolon after the Macro definition?\"\n        }\n        if (content.match(/\\s*;\\s*$/g)) {\n          errorMessage = \"There's a semicolon at the end.\"\n        }\n      // }\n\n      setBoxState({\n        ...state,\n        editor : {\n          ...state.editor,\n          syntaxError : new Error(errorMessage),\n        }\n      })\n\n      reportEvent('Submit Expression', 'submit invalid', content)\n    }\n  }\n\n  // THROWS Exceptions\n  parseExpression (expression : string, macrotable : MacroMap) : AST {\n    // const { macroTable } = this.props\n\n    const { SLI : singleLetterVars } = this.props.state\n\n    const tokens : Array<Token> = tokenize(expression, { lambdaLetters : ['λ'], singleLetterVars, macromap : macrotable })\n    const ast : AST = parse(tokens, macrotable) // macroTable\n\n    return ast\n  }\n\n}","import React from 'react'\n\nimport 'github-markdown-css/github-markdown-light.css'\nimport { NoteState } from './AppTypes'\nimport Editor from '../components/Editor'\n\nimport './styles/Note.css'\n\nimport ReactMarkdown from 'react-markdown'\n\nexport interface NoteProperties {\n  state : NoteState\n  isActive : boolean\n  isFocused : boolean\n  darkmode : boolean\n\n  setBoxState (state : NoteState) : void\n}\n\nexport default function Note (props : NoteProperties) : JSX.Element {\n  const {\n    state : {\n      note,\n      editor : { placeholder, content, syntaxError },\n      isEditing,\n    },\n    darkmode,\n    isActive,\n    setBoxState,\n  } = props\n  \n  const onContent = (content : string) => {\n    setBoxState({\n      ...props.state,\n      note : content,\n      editor : {\n        ...props.state.editor,\n        content,\n        syntaxError : null,\n      }\n    })\n    // this.updateURL(expression) // tohle musim nejak vyresit - mozna ta metoda setBoxState v APP bude checkovat propisovat do URL\n  }\n\n    if (isEditing) { // TODO: isFocused removed just for now\n    return (\n      <div className='box boxNoteEditor'>\n        <Editor\n          placeholder={ placeholder } // data\n          content={ content } // data\n          syntaxError={ syntaxError } // data\n          submitOnEnter={ false } // data\n          shouldReplaceLambda={ false }\n          darkmode={ darkmode }\n          \n          onContent={ onContent } // fn\n          onEnter={ () => void 0 } // fn\n          onCtrlEnter={ () => void 0 }\n          onShiftEnter={ () => void 0 }\n          onExecute={ () => {} } // fn\n          // onReset={ this.onClear } // fn not yet\n        />\n      </div>\n    )\n  }\n\n\n  return (\n    <div\n      className='box boxNote'\n      onClick={ () => \n        isActive &&\n        setBoxState({\n        ...props.state,\n        isEditing : true,\n      }) }\n    >\n      <ReactMarkdown className='markdown-body'>\n        { note }\n      </ReactMarkdown>\n    </div>\n  )\n}","import React from 'react'\n\nexport default function Empty (props : {}) : JSX.Element {\n  return (\n    <div>\n      Empty Box\n    </div>\n  )\n}","import React from 'react'\n\n// import Evaluator from './ExpressionBox'\n// import MacroDefinition from './MacroDefinition'\n// import Note from './Note'\n// import { MacroTableContext } from './EvaluatorSpace'\n// import { SetBoxContext } from './BoxSpace'\nimport { BoxType, BoxState } from '../Types'\n\nimport { UntypedLambdaState } from '../untyped-lambda-integration/Types'\n\nimport UntypedLambdaBox from '../untyped-lambda-integration/UntypedLambdaBox'\n\nimport { NoteState } from '../markdown-integration/AppTypes'\nimport Note from '../markdown-integration/Note'\n\nimport Empty from '../empty-integration'\n\n// import { BoxState } from '../AppTypes'\n\ninterface BoxProperties {\n  state : BoxState\n  isActive : boolean\n  isFocused : boolean\n  darkmode : boolean\n\n  updateBoxState (box : BoxState) : void\n  addBoxAfter (box : BoxState) : void\n}\n\nexport default function Box (props : BoxProperties) : JSX.Element {\n  const { state, isActive, isFocused, updateBoxState, addBoxAfter, darkmode } : BoxProperties = props\n  const { type } = state\n\n  // const macroTable = useContext(MacroTableContext)\n  // const setBoxState = useContext(SetBoxContext)\n\n\n  if (type === BoxType.UNTYPED_LAMBDA) {\n    return (\n      <UntypedLambdaBox\n        state={ state as UntypedLambdaState }\n        isActive={ isActive }\n        isFocused={ isFocused }\n        // macroTable={ macroTable }\n        darkmode={ darkmode }\n        \n        setBoxState={ updateBoxState }\n        addBox={ addBoxAfter }\n      />\n    )\n  }\n  if (type === BoxType.MARKDOWN) {\n    return (\n      <Note\n        state={ state as NoteState }\n        isActive={ isActive }\n        isFocused={ isFocused }\n        darkmode={ darkmode }\n\n        setBoxState={ updateBoxState }\n      />\n    )\n  }\n  else {\n    return (\n      <Empty />\n    )\n  }\n\n  // if (type === BoxType.MACRO) {\n  //   return (\n  //     <div className=''>\n  //       <MacroDefinition\n  //         state={ state as MacroDefinitionState }\n  //         setBoxState={ setBoxState }\n\n  //         // addBox={ addBox }\n  //       />\n  //     </div>\n  //   )\n  // }\n\n}","import React, { MouseEvent } from 'react'\n\nimport { UntypedLambdaState } from './Types'\nimport { BoxState } from '../Types'\n\nimport './styles/BoxTopBar.css'\n\n\ninterface Props {\n  state : UntypedLambdaState\n  isActive : boolean\n  removeBox : (e : MouseEvent) => void\n  updateBoxState : (box : BoxState) => void\n}\n\n\nexport default function BoxTopBar (props : Props) : JSX.Element {\n  const { state, updateBoxState } = props\n  const { macrolistOpen } = state\n\n  return (\n    <div className=''>\n\n      <div\n        onClick={ (e) => {\n          e.stopPropagation()\n          updateBoxState({ ...state, macrolistOpen : ! macrolistOpen })\n        } }\n        className={ `untyped-lambda--top-bar-custom--button ${macrolistOpen ? 'menu-pressed-open' : ''}` }\n        title={ macrolistOpen ? 'Hide Macros' : 'Show All Macros for This Box' }\n      >\n        <i className=\"mini-icon fas fa-list-ul\" />\n      </div>\n\n      {/* {\n        expression === '' ?\n          null\n        :\n        <Controls\n          isExercise={ isExercise }\n          makeExercise={ () =>\n            updateBoxState({\n              ...state,\n              isExercise : true,\n              editor: {\n                ...state.editor,\n                placeholder : PromptPlaceholder.VALIDATE_MODE,\n              },\n            })\n          }\n          endExercise={ () =>\n            updateBoxState({\n              ...state,\n              isExercise : false,\n              editor: {\n                ...state.editor,\n                placeholder : PromptPlaceholder.EVAL_MODE,\n              },\n            })\n          }\n        />\n      } */}\n\n      {/* <i\n        className='removeBox far fa-trash-alt'\n        onClick={ removeBox }\n        title='Remove this Box'\n      /> */}\n\n      {/* {\n        state.minimized ?\n          <i\n            className=\"imizeBox fas fa-sort-down\"\n            onClick={ (e : MouseEvent) => {\n              e.stopPropagation()\n              updateBoxState({ ...state, minimized : false })\n            } }\n            title='Expand this Box'\n          />\n          :\n          <i\n            className=\"imizeBox fas fa-sort-up\"\n            onClick={ (e : MouseEvent) => {\n              e.stopPropagation()\n              updateBoxState({ ...state, minimized : true })\n            } }\n            title='Collapse this Box'\n          />\n      } */}\n    </div>\n  )\n}","import React, { MouseEvent } from 'react'\n\nimport { NoteState } from './AppTypes'\n\nimport 'pretty-checkbox'\nimport './styles/EditingSwitch.css'\nimport { BoxState } from '../Types'\n\ninterface Props {\n  state : NoteState\n  isActive : boolean\n  removeBox : (e : MouseEvent) => void\n  updateBoxState : (box : BoxState) => void\n}\n\n\nexport default function BoxTopBar (props : Props) : JSX.Element {\n  const { state, updateBoxState } = props\n  const { isEditing } = state\n\n  return (\n    <div className=''>\n      {\n      // TODO: Remove This\n      /* <div className='topBarTitle' contentEditable={ true } suppressContentEditableWarning={true} onBlur={ (e) => updateBoxState({ ...state, title : e.target.textContent || \"\" }) }>\n        { title === \"\" ? \"Click Here to Change the Title\" : title }\n      </div> */}\n      <div className='markdown-controls' title='Edit as Markdown'>\n        \n        {/* This will be separated into it's own component */}\n        <div className='markdown-editing'>\n          <span\n            className={ `markdown-write ${isEditing ? 'markdown-selected' : ''}` }\n            onClick={ (e) => {\n              e.stopPropagation()\n              if (isEditing === false) {\n                updateBoxState({ ...state, isEditing : true})\n              }\n            } }\n          >\n            Edit\n          </span>\n          <span\n            className={ `markdown-preview ${isEditing ? '' : 'markdown-selected'}` }\n            onClick={ (e) => {\n              e.stopPropagation()\n              if (isEditing === true) {\n                updateBoxState({ ...state, isEditing : false})\n              }\n            } }\n          >\n            Preview\n          </span>\n        </div>\n      </div>\n\n      {/* <i\n        className='removeBox far fa-trash-alt'\n        onClick={ removeBox }\n        title='Remove this Box'\n      /> */}\n    </div>\n  )\n}","import React from 'react'\n\nexport default function EmptyTopBar (props : {}) : JSX.Element {\n  return (\n    <div></div>\n  )\n}","import React, { Component, MouseEvent } from 'react'\nimport { BoxType, BoxState, GlobalSettings } from '../Types'\nimport UntypedLambdaBTB from '../untyped-lambda-integration/BoxTopBar'\nimport { UntypedLambdaState } from '../untyped-lambda-integration/Types'\n\nimport MarkdownBTB from '../markdown-integration/BoxTopBar'\nimport { NoteState } from '../markdown-integration/AppTypes'\n\nimport EmptyBTB from '../empty-integration/BoxTopBar'\n\nimport '../styles/BoxTopBar.css'\nimport { resetUntypedLambdaBox } from '../untyped-lambda-integration/AppTypes'\n\n\ntype BoxPlace = 'before' | 'after'\n\ninterface Props {\n  state : BoxState\n  isActive : boolean\n  isFocused : boolean\n  removeBox : (e : MouseEvent) => void\n  updateBoxState : (box : BoxState) => void\n  addBoxBefore : (box : BoxState) => void\n  addBoxAfter : (box : BoxState) => void\n  settings : GlobalSettings\n}\n\ninterface State {\n  where : BoxPlace | null\n  menuOpen : boolean\n  shareLinkOpen : boolean\n}\n\n\nexport default class BoxTitleBar extends Component<Props, State> {\n\n  constructor (props : Props) {\n    super(props)\n\n    this.state = {\n      where : null,\n      menuOpen : false,\n      shareLinkOpen : false,\n    }\n  }\n\n  render () : JSX.Element {\n    const { state, isActive, updateBoxState, removeBox } : Props = this.props\n    const { type, title, minimized } = state\n\n    const { shareLinkOpen } : State = this.state\n\n    return (\n      <div className='boxTopBar'\n        onClick={ (e) => e.stopPropagation() }\n      >\n        <div\n          className='topBarTitle'\n        >\n          <span\n                className='box-top-bar--title-text'\n                contentEditable={ true }\n                suppressContentEditableWarning={true}\n                onClick={ (e) => {\n                  // NOTE: this is really ugly and dangerous quick fix\n                  // I am trying to fix a bug where for some reason markdown boxes, when clicked into title\n                  // it causes focus, then immidiately it loses focus\n                  // so now, when I click in the title, I won't make it active at all\n                  e.stopPropagation()\n                } }\n                onBlur={ (e) => updateBoxState({ ...state, title : e.target.textContent || \"\" })  }\n              >\n              { title }\n          </span>\n        </div>\n\n        <div className='box-top-bar-custom'>\n          {\n            (type === BoxType.UNTYPED_LAMBDA) ? \n              (\n                <UntypedLambdaBTB\n                  state={ state as UntypedLambdaState }\n                  isActive={ isActive }\n                  removeBox={ removeBox }\n                  updateBoxState={ updateBoxState }\n                />\n              )\n            :\n            (type === BoxType.MARKDOWN) ?\n              (\n                <MarkdownBTB\n                  state={ state as NoteState }\n                  isActive={ isActive }\n                  removeBox={ removeBox }\n                  updateBoxState={ updateBoxState }\n                />\n              )\n            :\n              (\n                <EmptyBTB />\n              )\n          }\n\n        </div>\n        <div className='box-top-bar-controls'>\n          <div\n              className='box-top-bar--controls-item'\n              onClick={ removeBox }\n              title='Delete this Box from the Notebook'\n            >\n              <i\n                className='mini-icon far fa-trash-alt'\n              />\n            </div>\n          \n          {\n            type !== BoxType.MARKDOWN ?\n            <div\n              onClick={ (e) => {\n                e.stopPropagation()\n                updateBoxState({ ...state, minimized : ! minimized })\n              } }\n              className='box-top-bar--controls-item'\n              title={ minimized ? 'Expand this Box' : 'Collapse this Box' }\n            >\n              {\n                minimized ?\n                  <i className=\"mini-icon fas fa-expand\" />\n                :\n                  <i className=\"mini-icon fas fa-compress\" />\n              }\n            </div>\n            :\n              null\n          }\n\n          {\n            type !== BoxType.MARKDOWN ?\n              <div\n                className='box-top-bar--controls-item'\n                title=\"Open this Boxs' settings\"\n                onClick={ (e) => {\n                  e.stopPropagation()\n                  updateBoxState({ ...state, settingsOpen : ! state.settingsOpen })\n                }}\n              >\n                <i className=\"mini-icon fas fa-cogs\"/>\n              </div>\n            :\n            null\n          }\n\n          <div\n            className='box-top-bar--controls-item'\n            onClick={ (e) => {\n              e.stopPropagation()\n              this.setState({ shareLinkOpen : true })\n              const searchParams : URLSearchParams = new URL(window.document.location.toString()).searchParams\n\n              searchParams.set('type', state.type)\n\n              if (state.type === BoxType.UNTYPED_LAMBDA) {\n                const macros = encodeURI(JSON.stringify((state as UntypedLambdaState).macrotable))\n                searchParams.set('source', encodeURI((state as UntypedLambdaState).ast?.toString() || (state as UntypedLambdaState).editor.content))\n                searchParams.set('macros', macros)\n              }\n              else {\n                searchParams.set('source', encodeURI((state as any).editor.content)) // todo: fix that `as any`\n              }\n\n              if (state.type === BoxType.UNTYPED_LAMBDA) {\n                searchParams.set('subtype', (state as UntypedLambdaState).subtype)\n                searchParams.set('strategy', (state as UntypedLambdaState).strategy)\n                searchParams.set('SDE', (state as UntypedLambdaState).SDE.toString())\n                searchParams.set('SLI', (state as UntypedLambdaState).SLI.toString())\n              }\n\n              const url : string = window.location.host + '?' + searchParams.toString()\n\n              navigator.clipboard.writeText(url)\n\n              setTimeout(() => this.setState({ shareLinkOpen : false, menuOpen : false }), 1500)\n\n            } }\n            title='Copy the link to this Expression.'\n          >\n            <i className=\"mini-icon fas fa-share-alt-square\"></i>\n          </div>\n\n          <div\n            className='box-top-bar--controls-item'\n            onMouseDownCapture={ e => {\n              e.preventDefault()\n              e.stopPropagation()\n            } }\n            // ^^^ this function is just a dirty quick bug fix\n            // when you are editing and click on the edit button again\n            // on the mouse down - the box loses focus and then on mouse up\n            // the onClick is finished and it is then again focused\n            // so the result looks awkward\n            // the previous line is a black hole for the mousedown event\n            // that way it can't cause losing focus for the box, because it is stoped\n            onClick={ (e) => {\n              console.log('clicked on the EDIT button')\n              e.stopPropagation()\n\n              switch (type) {\n                case BoxType.UNTYPED_LAMBDA: {\n                  const resetState : UntypedLambdaState = resetUntypedLambdaBox(state as UntypedLambdaState)\n                  const content : string = (state as UntypedLambdaState).expression || (state as UntypedLambdaState).editor.content\n\n                  updateBoxState({\n                    ...resetState,\n                    editor : {\n                      ...resetState.editor,\n                      content, \n                    }\n                  })\n                  break\n                }\n                case BoxType.MARKDOWN: {\n                  updateBoxState({ ...state, isEditing : true })\n                  break\n                }\n              }\n              this.setState({ menuOpen : false })\n            } }\n            title='Edit this Expression.'\n          >\n            <i className=\"mini-icon far fa-edit\"></i>\n          </div>\n        </div>\n\n        {\n          shareLinkOpen ?\n            <p className='box-top-bar--menu-item--notif'>\n              Link Copied!\n            </p>\n            :\n            null\n        }\n\n      </div>\n      )\n    }\n\n}","import React, { MouseEvent, Component } from 'react'\nimport { mapBoxTypeToStr } from '../Constants'\nimport Box from './Box'\nimport BoxTitleBar from './BoxTitleBar'\nimport { BoxState, GlobalSettings } from '../Types'\n\nimport \"../styles/BoxContainer.css\"\nimport PickBoxTypeModal from './PickBoxTypeModal'\n\n\ninterface Props {\n  isActiveBox : boolean\n  isFocusedBox : boolean\n  box : BoxState\n  darkmode : boolean\n\n  makeActive : () => void\n  onBlur : () => void\n  updateBoxState : (state : BoxState) => void\n  removeBox : () => void\n  addBoxBefore : (state : BoxState) => void\n  addBoxAfter : (state : BoxState) => void\n  settings : GlobalSettings\n}\n\ninterface State {\n  modalOpen : boolean\n}\n\nexport class BoxContainer extends Component<Props, State> {\n  constructor (props: Props) {\n    super(props)\n\n    this.state = {\n      modalOpen : false\n    }\n  }\n\n  render () : JSX.Element {\n    const {\n      isActiveBox,\n      isFocusedBox,\n      box,\n      makeActive,\n      onBlur,\n      updateBoxState,\n      addBoxBefore,\n      addBoxAfter,\n      removeBox,\n      darkmode\n    } : Props = this.props\n  \n    const { modalOpen } = this.state\n  \n    const boxTypeClassName : string = mapBoxTypeToStr(box.type)\n  \n    return (\n      <div>\n        <div\n          className={ `boxContainer ${ isActiveBox ? 'active' : 'inactive' } ${boxTypeClassName}` }\n          onClick={ makeActive }\n          onBlur={ onBlur }\n        >\n          <BoxTitleBar\n            state={ box }\n            isActive={ isActiveBox }\n            isFocused={ isFocusedBox }\n            removeBox={ (e : MouseEvent) => {\n              e.stopPropagation()\n              removeBox()\n            } }\n            updateBoxState={ updateBoxState }\n            addBoxBefore={ addBoxBefore }\n            addBoxAfter={ addBoxAfter }\n            settings={ this.props.settings }\n          />\n          \n          <Box\n            state={ box }\n            isActive={ isActiveBox }\n            isFocused={ isFocusedBox }\n            updateBoxState={ updateBoxState }\n            addBoxAfter={ addBoxAfter }\n            darkmode={ darkmode }\n          />\n        </div>\n\n        {\n          modalOpen ?\n            <PickBoxTypeModal\n              addNew={ (box : BoxState) => {\n                this.props.addBoxAfter(box)\n                this.setState({ modalOpen : false })\n              } }\n              settings={ this.props.settings }\n            />\n          :\n          <div className=\"add_box_after\" onMouseDown={ () => this.setState({ modalOpen : true }) } >\n            +\n          </div>\n        }\n      </div>\n    )\n  }\n}","// This component needs to be able to specify which Boxes are allowed inside\n// It will also have other settings - maybe something like lock - if it's locked, you can not modify it\n// Exam mode will feature the build of the Frontend which will not import any of the Evaluation Boxes\n\n\nimport React, { PureComponent } from 'react'\nimport CreateBox from '../components/CreateBox'\nimport { BoxType, NotebookState, GlobalSettings, BoxState } from '../Types'\n\nimport { onMarkDownBlur, NoteState, onMarkDownActive } from '../markdown-integration/AppTypes'\nimport { BoxContainer } from '../components/BoxContainer'\n\ninterface Props {\n  state : NotebookState\n  settings : GlobalSettings\n  darkmode : boolean\n\n  updateNotebook (notebook : Partial<NotebookState>) : void\n}\n\nexport default class Notebook extends PureComponent<Props> {\n  constructor (props : Props) {\n    super(props)\n\n    this.insertBefore = this.insertBefore.bind(this)\n    this.insertAfter = this.insertAfter.bind(this)\n    this.removeBox = this.removeBox.bind(this)\n    this.updateBoxState = this.updateBoxState.bind(this)\n    this.makeActive = this.makeActive.bind(this)\n    this.onBlur = this.onBlur.bind(this)\n    this.createBoxFromURL = this.createBoxFromURL.bind(this)\n    this.setBoxState = this.setBoxState.bind(this)\n    this.updateURL = this.updateURL.bind(this)\n  }\n\n  // componentDidMount () : void {\n  //   this.createBoxFromURL()\n  // }\n\n  render () {\n    const { state, settings, darkmode } = this.props\n    const { activeBoxIndex, focusedBoxIndex, boxList } = state\n\n    return (\n      <div className=\"mainSpace\">\n        {/* TODO: This will be refactore out to standalone component. */}\n        <ul className=\"boxList UL\">\n          { boxList.map(\n            (box : BoxState, i : number) =>\n            <li className=\"LI\" key={ box.__key }>\n\n              {/* <CreateBox\n                addNew={ (box : BoxState) => this.insertBefore(i, box) }\n                whiteList={ allowedBoxes }\n                settings={ settings }\n              /> */}\n\n              <BoxContainer\n                box={ box}\n                isActiveBox={ activeBoxIndex === i}\n                isFocusedBox={ focusedBoxIndex === i }\n                addBoxBefore={ (box : BoxState) => this.insertBefore(i, box) }\n                addBoxAfter={ (box : BoxState) => this.insertAfter(i, box) }\n                makeActive={ () => this.makeActive(i) }\n                removeBox={ () => this.removeBox(i) }\n                updateBoxState={ (box : BoxState) => this.updateBoxState(i, box) }\n                onBlur={ () => this.onBlur(i) }\n                settings={ settings }\n                darkmode={ darkmode }\n              />\n            </li>\n          ) }\n\n          {\n            boxList.length === 0 ?\n              <div className='top-level--create-box'>\n                <CreateBox\n                  addNew={ (box : BoxState) => this.insertBefore(state.boxList.length, box) }\n                  settings={ settings }\n                />\n              </div>\n            :\n            null\n          }\n        </ul>\n      </div>\n    )\n  }\n\n  /**\n   * URL params:\n   *  type : untyped-lambda | markdown | lisp | ... \n   *  specific : {\n   *    SLI : nul\n   *    strategy : normal | applicative | simplyfied\n   *  }\n   *  source : string\n   */\n  createBoxFromURL () {\n    const urlSearchParams : URLSearchParams = new URL(window.location.toString()).searchParams\n    const type : string | null = urlSearchParams.get('type')\n\n    if (type === null) {\n      return\n    }\n\n    // switch (type) {\n    //   case BoxType.UNTYPED_LAMBDA: {\n\n    //   }\n        \n    //   default:\n    //     break;\n    // }\n    \n    // console.log(window.location.toString())\n    // console.log(urlSearchParams.get('type'))\n    // console.log(urlSearchParams.get('source'))\n\n\n\n\n    // const hash : string = decodeURI(window.location.hash.substring(1))\n    // const isExercise : boolean = hash.indexOf('exercise:') !== -1\n\n    // const expression : string = isExercise ? hash.substring(9) : hash\n\n    // if (expression === '') {\n    //   // return\n    // }\n\n    // const box : BoxState = {\n    //   type : BoxType.EXPRESSION,\n    //   __key : Date.now().toString(),\n    //   expression : '',\n    //   ast : null,\n    //   history : [],\n    //   isRunning : false,\n    //   breakpoints : [],\n    //   timeoutID : undefined,\n    //   timeout : 10,\n    //   isExercise : isExercise,\n    //   strategy : this.getActiveStrategy(),\n    //   singleLetterNames : this.getActiveSingleLetterNames(),\n    //   standalones : this.getActiveStandalones(),\n    //   editor : {\n    //     placeholder : PromptPlaceholder.INIT,\n    //     content : expression,\n    //     caretPosition : expression.length,\n    //     syntaxError : null,\n    //   }\n    // }\n\n    // this.setState({\n    //   ...this.state,\n    //   submittedBoxes : [ box ],\n    //   activeBoxIndex : 0,\n    // })\n  }\n\n  setBoxState (index : number, boxState : BoxState) : void {\n    // const { submittedBoxes } = this.state\n    \n    // const expression : string = boxState.type === BoxType.EXPRESSION ? boxState.editor.content || (boxState as EvaluationState).expression : '' // TODO: DIRTY DIRTY BIG TIME\n    // const expPrefix : string = boxState.type === BoxType.EXPRESSION && (boxState as EvaluationState).isExercise ? 'exercise:' : '' \n    \n    // history.pushState({}, \"page title?\", \"#\" + expPrefix + encodeURI(expression))\n\n    // // TODO: doresit update URL // ted uz to docela dobry je\n\n    // // TODO: consider immutability\n    // submittedBoxes[index] = boxState\n\n    // this.setState({\n    //   ...this.state,\n    //   submittedBoxes,\n    // })\n\n  }\n\n  insertBefore (index : number, box : BoxState) : void {\n    const { boxList } = this.props.state\n\n    const boxListCopy = [ ...boxList ]\n\n    boxListCopy.splice(index, 0, box)\n\n    this.props.updateNotebook({ boxList : boxListCopy, activeBoxIndex : index, focusedBoxIndex : index })\n  }\n\n  insertAfter (index : number, box : BoxState) : void {\n\n    const { boxList } = this.props.state\n\n    boxList.splice(index + 1, 0, box)\n    this.props.updateNotebook({ boxList : boxList, activeBoxIndex : index + 1, focusedBoxIndex : index + 1})\n  }\n\n  removeBox (index : number) : void {\n    const { boxList, activeBoxIndex } = this.props.state\n    \n    const nearestValidIndex = (i : number) => {\n      if (i < activeBoxIndex) return activeBoxIndex - 1\n      if (i > activeBoxIndex) return activeBoxIndex\n      if (boxList.length === 1) return NaN\n      if (i === 0) return i\n      return i - 1\n    }\n\n    const newIndex : number = nearestValidIndex(index)\n\n    boxList.splice(index, 1)\n    this.props.updateNotebook({ boxList : boxList, activeBoxIndex : newIndex })\n  }\n\n  updateBoxState (index : number, box : BoxState) : void {\n    // console.log('UPDATING BOX STATE')\n    const { boxList } = this.props.state\n    boxList[index] = { ...box }\n\n    this.updateURL(box)\n\n\n    this.props.updateNotebook({ boxList : [...boxList], activeBoxIndex : index })\n  }\n\n  makeActive (index : number) : void {\n    // console.log(\"CLICKED ON               MAKE ACTIVE \" + index)\n    const { activeBoxIndex, focusedBoxIndex, boxList } = this.props.state\n\n    const currentType : BoxType = boxList[activeBoxIndex].type\n\n    switch (currentType) {\n      case BoxType.UNTYPED_LAMBDA:\n        // boxList[activeBoxIndex] = onUntypedLambdaBlur(boxList[activeBoxIndex])\n        break\n      \n      case BoxType.MARKDOWN: {\n        boxList[activeBoxIndex] = onMarkDownBlur(boxList[activeBoxIndex] as NoteState)\n        break\n      }\n\n      default:\n        break\n    }\n\n    if (index !== activeBoxIndex || index !== focusedBoxIndex || boxList[index].minimized === true) {\n      const futureType : BoxType = boxList[index].type\n\n      const patch = {\n        minimized : false,\n      }\n\n      switch (futureType) {\n        case BoxType.MARKDOWN:\n          boxList[index] = {\n            ...onMarkDownActive(boxList[index] as NoteState),\n            ...patch,\n          }\n          break\n          \n        default:\n          boxList[index] = {\n            ...boxList[index],\n            ...patch\n          }\n          break\n      }\n\n      this.updateURL(boxList[index])\n\n      this.props.updateNotebook({ activeBoxIndex : index, focusedBoxIndex : index, boxList })\n    }\n  }\n\n  onBlur (index : number) : void {\n    // TODO: I may not need onBlur handling in the future\n    // I am thinking - right now all it does is this:\n    // it un-focuses currently focused Box\n    // if this is not really needed - then maybe I should not have this feature\n    // console.log('..................................')\n    // console.log(\"                  BLUR \" + index)\n\n    const { boxList, activeBoxIndex } = this.props.state\n\n    if (activeBoxIndex !== index) {\n      return\n    }\n\n    const currentType : BoxType = boxList[index].type\n\n    switch (currentType) {\n      case BoxType.UNTYPED_LAMBDA:\n        // boxList[activeBoxIndex] = onUntypedLambdaBlur(boxList[activeBoxIndex])\n        break\n      \n      case BoxType.MARKDOWN:\n        boxList[index] = onMarkDownBlur(boxList[index] as NoteState)\n        // return // TODO: just for now\n      break\n\n      default:\n        break\n    }\n\n    this.props.updateNotebook({ boxList, focusedBoxIndex : undefined })\n  }\n\n  updateURL (box : BoxState) : void {\n    return\n    // switch (box.type) {\n    //   case BoxType.MARKDOWN : {\n    //     const searchParams : URLSearchParams = new URL(window.document.location.toString()).searchParams\n\n    //     searchParams.set('type', BoxType.MARKDOWN)\n    //     searchParams.set('source', encodeURI((box as NoteState).editor.content))\n\n    //     window.history.pushState(null, '', '?' + searchParams.toString())\n    //     break;\n    //   }\n\n    //   case BoxType.UNTYPED_LAMBDA : {\n    //     const searchParams : URLSearchParams = new URL(window.document.location.toString()).searchParams\n\n    //     searchParams.set('type', BoxType.UNTYPED_LAMBDA)\n    //     searchParams.set('source', encodeURI((box as UntypedLambdaState).editor.content))\n\n    //     window.history.pushState(null, '', '?' + searchParams.toString())\n\n    //     break;\n    //   }\n    \n    //   default:\n    //     break;\n    // }\n  }\n}","const content : string = `# User guide\n\n## Typing expressions\n#### To write lambda expression you simply type in the prompt.\n\n## Typing λ symbol\n#### If you want to write \\`λ\\` symbol inside of the Interactive Box - you simply type \\`\\\\\\` and Lambdulus will take care of the rest.\n\n#### If you need to write \\`λ\\` symbol inside of the Markdown Box - you can use \\`&lambda;\\` sequence.\n\n## Multiple expressions\n#### You can also have many submitted expressions. To submit another expression you need to either click the big \\`+\\` sign in the empty notebook, or to click on the \\`three dots\\` menu and pick whether you want to open new box before or after your current Box.\n\n## Single Letter Names (SLI)\n#### You can write lambda functions and omit whitespaces such as \\`(λabc.cba) 2 1 +\\`. To do that you have to check switch \\`Single Letter Names\\` at the top of the page.\n#### You can always override the global SLI setting for the specific Box.\n\n## Evaluation Strategies\n#### We have option to select from 3 evaluation strategies. The \\`Simplified\\` strategy is specific evaluation order which evaluates built-in macros atomicaly. The \\`Normal\\` and the \\`Applicative\\` strategies are sort of self describing.\n\n## Macros\n#### In case you need to define your own macros, you can do that in the same prompt you use to input lambda expression. Each Macro Definition consists of the name of the macro followed by \\`:=\\` symbol and the lambda expression. Note that between each macro definition and the following term (either another macro or the lambda expression to evaluate) you must put \\`;\\` as a delimiter.\n#### Also note that each Box has it's own namespace, macros in one Box are not accessible in other Boxes.\n\n## Macro Definition\n#### Inside the macro definition you can reference any valid macro which is already defined or will be defined in the future. You can, in fact, reference the same macro you are currently defining inside it's own definition - whether you should do it or not is up to you.\n\n## List All Macros\n#### If you want to list all defined macros - built-ins and also your macros - you simply click on the *list resembling* icon at the right top of the Box.\n\n## Remove or Redefine User Macro\n#### To remove or rewrite your macros - \\`because you can not remove built-ins\\` - you need to click on the \"pencil\" icon at the top right part of the Box. That will reset the Box back to the \"editor stage\", you can now modify your macros and evaluate the expression again. You might also need want to rewrite your lambda expression in case it references the macro being removed.\n\n## Report a Bug or Request New Features\n#### If you want to report a bug or you need some feature - click on the \\`Issues\\` button on the left or at the top of the page. Then fill in the issue on the GitHub page of the project. Definitely don't forget to check if the corresponding issue already exist.\n`\n\nexport default content\n","import React from 'react'\nimport 'github-markdown-css/github-markdown-light.css'\n\nimport guide from '../misc/UserGuide'\nimport ReactMarkdown from'react-markdown'\n\nexport default function Help (props : { darkmode : boolean }) : JSX.Element {\n  (window as any).guide = guide\n  return (\n  <div className='helpSpace'>\n    <ReactMarkdown className='markdown-body'>\n      { guide }\n    </ReactMarkdown>\n    <br />\n    <br />\n    <br />\n    { `version: ${process.env.REACT_APP_VERSION_INFO}` }\n    <br />\n    { `commit hash: ${process.env.REACT_APP_COMMIT}` }\n  </div>)\n}","import React from 'react'\n\nimport UntypedLambdaCalculusSet from '../untyped-lambda-integration/Settings'\nimport {\n  CODE_NAME as UNTYPED_CODE_NAME,\n  GLOBAL_SETTINGS_ENABLER as UNTYPED_GLOBAL_SETTINGS_ENABLER\n} from '../untyped-lambda-integration/AppTypes'\nimport { GlobalSettings } from '../Types'\nimport { UntypedLambdaSettings } from '../untyped-lambda-integration/Types'\n\n\ninterface Props {\n  settings : GlobalSettings\n  updateSettings : (settings : GlobalSettings) => void\n}\n\nexport default function SettingsScreen (props : Props) : JSX.Element {\n  const { settings, updateSettings } = props\n\n  const untypedSettings : UntypedLambdaSettings = settings[UNTYPED_CODE_NAME] as UntypedLambdaSettings\n\n  return (\n    <div className='settingsSpace'>\n      <h2>\n        Settings for Untyped Lambda Calculus:\n      </h2>\n      <UntypedLambdaCalculusSet\n        settings={ untypedSettings }\n        settingsEnabled={ UNTYPED_GLOBAL_SETTINGS_ENABLER }\n        change={\n          (unTypLSet : UntypedLambdaSettings) =>\n            updateSettings({ ...settings, [UNTYPED_CODE_NAME] : unTypLSet })\n        }\n      />\n    </div>\n  )\n}","import React from 'react'\nimport { AppState, NotebookState } from '../Types'\n\nimport '../styles/NotebookList.css'\nimport Notebook from './Notebook'\n\ninterface Props {\n  state : AppState\n  darkmode : boolean\n\n  onSelectNotebook (index : number) : void\n  onRemoveNotebook (index : number) : void\n  onUpdateNotebook (notebook : NotebookState, index : number) : void\n  onAddNotebook (string ? : string) : void\n}\n\nexport default function NotebookList (props : Props) : JSX.Element {\n  const { state, onSelectNotebook, onRemoveNotebook, onUpdateNotebook, onAddNotebook, darkmode } : Props = props\n  const { notebookList } : AppState = state\n\n  return (\n    <div className='mainSpace'>\n      <ul className='notebook-list UL'>\n        <li\n          className='LI cursor-pointer notebook-list--add-notebook cursor-pointer notebook-list--notebook'\n          onClick={ (e) => {\n            e.stopPropagation()\n            \n            const name : string | null = prompt('Please Write the Name of New Notebook')\n\n            if (name !== null) {\n              onAddNotebook(name)\n              return\n            }\n\n            // onAddNotebook() // don't add new notebook when user cancels the prompt\n          }}\n        >\n          <div className='notebook-list--add-notebook--container'>\n            <i className=\"mini-icon fas fa-plus\" />\n          </div>\n        </li>\n        {\n          notebookList.map((notebook : NotebookState, index : number) =>\n            <li className='LI cursor-pointer notebook-list--notebook' key={notebook.__key} onClick={ () => onSelectNotebook(index) }>\n              <div className='notebook-list--notebook-thumbnal'>\n                <Notebook\n                  state={ notebook }\n                  settings={ notebook.settings }\n                  updateNotebook={ () => void 0 }\n                  darkmode={ darkmode }\n                />\n              </div>\n              <div className='notebook-list--notebook-footer'>\n                <span className='notebook-list--notebook-footer--title'>\n                  { notebook.name }\n                </span>\n                <div className='notebook-list--notebook-footer--menu'>\n                  <div\n                    onClick={ (e) => {\n                      e.stopPropagation()\n                      onUpdateNotebook({ ...notebook, menuOpen : ! notebook.menuOpen }, index)\n                    } }\n                    className={ `notebook-list--notebook--menu--dots ${notebook.menuOpen ? 'menu-pressed-open' : ''}` }\n                  >\n                    <i className=\"mini-icon fas fa-ellipsis-v\"></i>\n                  </div>\n                </div>\n              </div>\n              {\n                notebook.menuOpen ?\n                  <div\n                    className='notebook-list--notebook--menu'\n                    ref={ (elem : any) => {\n                      // just to be able to always see the menu\n                      if (elem !== null) {\n                        const boundingRect = elem.getBoundingClientRect()\n                        const viewportHeight : number = window.innerHeight\n                        if (boundingRect.bottom > viewportHeight) {\n                          elem.scrollIntoView(false)\n                        }\n                      }\n                    } }  \n                  >\n                    {/* TODO: move into ... menu */}\n                    <div\n                      className='box-top-bar--menu-item'\n                      onClick={ (e) => {\n                        e.stopPropagation()\n                        onRemoveNotebook(index)\n                      } }\n                    >\n                      Remove\n                      {/* <i\n                        className='mini-icon far fa-trash-alt'\n                        onClick={ removeBox }\n                        title='Remove this Box'\n                      /> */}\n                    </div>\n\n                    <div\n                      className='box-top-bar--menu-item'\n                      onClick={ (e) => {\n                        e.stopPropagation()\n                        const name : string | null = prompt('Please Enter New Name for the Notebook')\n\n                        if (name !== null && name !== \"\") {\n                          onUpdateNotebook({ ...notebook, name, menuOpen : false }, index)\n                        }\n                        else {\n                          onUpdateNotebook({ ...notebook, menuOpen : false }, index)\n                        }\n                      } }\n                    >\n                      Rename\n                    </div>\n                  </div>\n                :\n                null\n\n              }\n            </li>\n          )\n\n        }\n      </ul>\n    </div>\n  )\n}","import React, { Component } from 'react'\n\nimport './App.css'\n\nimport  { updateSettingsInStorage\n        , loadAppStateFromStorage\n        , updateAppStateToStorage\n        , updateNotebookStateToStorage\n        , CLEAR_WORKSPACE_CONFIRMATION\n        , loadSettingsFromStorage\n        , InitNotebookState } from './Constants'\n\nimport TopBar from './components/TopBar'\nimport MenuBar from './components/MenuBar'\nimport Notebook from './screens/Notebook'\nimport Help from './screens/Help'\nimport SettingsScreen from './screens/Settings'\nimport { Screen, AppState, NotebookState, GlobalSettings, BoxType, BoxState } from './Types'\nimport { createNewUntypedLambdaBoxFromSource, defaultSettings } from './untyped-lambda-integration/AppTypes'\nimport NotebookList from './screens/NotebookList'\nimport { UntypedLambdaState, UntypedLambdaSettings, EvaluationStrategy, UntypedLambdaType } from './untyped-lambda-integration/Types'\nimport { MacroTable } from '@lambdulus/core'\n\n\n\n/**\n * This is the main Application\n * in the future - when building Exam Mode - I will need to replace some part of the application components\n * if it's only some component at the top, it can be done easily\n * if it's gonna replace some deeper stuff I will need to implement some Namespace FROM which app and integrations\n * will inport parts and this Namespace will take care of that\n */\n\n\ninterface Props {}\nexport default class App extends Component<Props, AppState> {\n  constructor (props : Props) {\n    super(props)\n\n    console.log(`VERSION: ${process.env.REACT_APP_VERSION_INFO}`)\n    console.log(`COMMIT: ${process.env.REACT_APP_COMMIT}`)\n\n\n    this.state = loadAppStateFromStorage()\n\n    this.setScreen = this.setScreen.bind(this)\n    this.updateNotebook = this.updateNotebook.bind(this)\n    this.changeNotebook = this.changeNotebook.bind(this)\n    this.addNotebook = this.addNotebook.bind(this)\n    this.removeNotebook = this.removeNotebook.bind(this)\n    this.editNotebookName = this.editNotebookName.bind(this)\n    this.changeNotebookName = this.changeNotebookName.bind(this)\n    this.stopEditingNotebook = this.stopEditingNotebook.bind(this)\n    this.updateSettings = this.updateSettings.bind(this)\n    this.importNotebook = this.importNotebook.bind(this)\n    // this.importWorkspace = this.importWorkspace.bind(this)\n    this.clearWorkspace = this.clearWorkspace.bind(this)\n    this.selectNotebook = this.selectNotebook.bind(this)\n    this.updateNthNotebook = this.updateNthNotebook.bind(this)\n    this.toggleDarkMode = this.toggleDarkMode.bind(this)\n\n    this.createNotebookFromURL = this.createNotebookFromURL.bind(this)\n  }\n\n  componentDidMount () : void {\n    this.createNotebookFromURL()\n  }\n\n  // TODO: all of this needs to be moved to more apropriate component\n  // maybe something like Notebook or similar -- this just isn't right\n\n  // I don't think it should get moved to the component, standalone helper function would be OK\n  // OR -> split it --> there will be very simple top level abstraction implementation\n  // and according the type of the BOX - specific Integration Module will handle the actual deserialization\n  createNotebookFromURL () {\n    const urlSearchParams : URLSearchParams = new URL(window.location.toString()).searchParams\n    const type : string | null = urlSearchParams.get('type')\n\n    if (type === null) {\n      return\n    }\n\n    switch (type) {\n      case BoxType.UNTYPED_LAMBDA: {\n        const source : string | null = urlSearchParams.get('source')\n        const macros : string | null = urlSearchParams.get('macros')\n        const subtype : string | null = urlSearchParams.get('subtype')\n        const strategy : string | null = urlSearchParams.get('strategy')\n        const SDE : string | null = urlSearchParams.get('SDE')\n        const SLI : string | null = urlSearchParams.get('SLI')\n        \n        if (source === null || macros == null || subtype === null || strategy === null || SDE === null || SLI === null) {\n          return\n        }\n\n        const strat : EvaluationStrategy = EvaluationStrategy.NORMAL === strategy ? EvaluationStrategy.NORMAL : EvaluationStrategy.APPLICATIVE\n\n        const sli : boolean = SLI === 'true' ? true : false\n\n        const settings : UntypedLambdaSettings = { ...defaultSettings, strategy : strat, SDE : SDE === 'true' ? true : false, SLI : sli }\n\n        const sub : UntypedLambdaType = subtype === UntypedLambdaType.EMPTY ?\n            UntypedLambdaType.EMPTY\n          :\n            subtype === UntypedLambdaType.ORDINARY ?\n              UntypedLambdaType.ORDINARY\n            :\n              subtype === UntypedLambdaType.EXERCISE ?\n                UntypedLambdaType.EXERCISE\n              :\n                UntypedLambdaType.EMPTY\n\n        try {\n          const macrotable : MacroTable = JSON.parse(decodeURI(macros))\n\n          const box : UntypedLambdaState = createNewUntypedLambdaBoxFromSource(decodeURI(source), settings, sub, macrotable)\n          const notebook : NotebookState = createNewNotebookWithBox('Notebook from Link' , box)\n\n          this.setState({\n            currentScreen : Screen.MAIN,\n            notebookList : [ notebook, ...this.state.notebookList ],\n            currentNotebook : 0\n          })\n\n          window.history.pushState(null, '', '/') // TODO: decide if remove or leave\n\n          updateAppStateToStorage({\n            ...this.state,\n            currentScreen : Screen.MAIN,\n            notebookList : [ ...this.state.notebookList, notebook ],\n            currentNotebook : this.state.notebookList.length - 1\n          })\n        }\n        catch (ex) {\n          window.history.replaceState(null, '', '/') // TODO: decide if remove or leave\n        }\n      }\n      break\n        \n      default:\n        break;\n    }\n  }\n\n  // NOTE: render is OK\n  render () {\n    const { notebookList, currentNotebook, currentScreen, darkmode } = this.state\n    const state = notebookList[currentNotebook]\n    const { settings } = state\n\n    return (\n      <div id='app' className={ darkmode ? 'dark' : 'light' }>\n        <div id=\"bad-screen-message\">\n          Lambdulus only runs on screens at least 900 pixels wide.\n        </div>\n        <TopBar\n          state={ this.state }\n          onScreenChange={ this.setScreen }\n          onImport={ this.importNotebook }\n          onClearWorkspace={ this.clearWorkspace }\n          onDarkModeChange={ this.toggleDarkMode }\n        />\n\n\n        <MenuBar\n          state={ this.state }\n          onScreenChange={ this.setScreen }\n        />\n\n        { (() => {\n          switch (currentScreen) {\n            case Screen.MAIN:\n              return <Notebook state={ state } updateNotebook={ this.updateNotebook } settings={ settings } darkmode={ darkmode } />\n\n            case Screen.NOTEBOOKS:\n              return  <NotebookList\n                      state={ this.state }\n                      onSelectNotebook={ this.selectNotebook }\n                      onRemoveNotebook={ this.removeNotebook }\n                      onUpdateNotebook={ this.updateNthNotebook }\n                      onAddNotebook={ this.addNotebook }\n                      darkmode={ darkmode }\n                    />\n\n            case Screen.HELP:\n              return <Help darkmode={ darkmode } />\n\n            case Screen.SETTINGS:\n              return <SettingsScreen settings={ settings } updateSettings={ this.updateSettings } />\n          }\n        })()}\n      </div>\n    )\n  }\n\n  // NOTE: selectNotebook is ALMOST OK\n  selectNotebook (index : number) : void {\n    this.setState({\n      currentScreen : Screen.MAIN, // TODO: why am I setting the Screen too?\n      currentNotebook : index,\n    })\n\n    updateAppStateToStorage({\n      ...this.state,\n      currentScreen : Screen.MAIN, // TODO: why am I setting the Screen too?\n      currentNotebook : index,\n    })\n\n    // CHANGED:\n    // window.history.pushState(null, '', '/')\n    // NOTE: I think this is from the time, when prompt content was also propagated to the URL bar\n    // so it shouldn't be needed anymore\n  }\n\n  // NOTE: setScereen is OK\n  setScreen (screen : Screen) : void {\n    this.setState({ currentScreen : screen })\n  }\n\n  updateNotebook (notebook : Partial<NotebookState>) : void {\n    const { notebookList, currentNotebook } = this.state\n\n    notebookList[currentNotebook] = {\n      ...notebookList[currentNotebook],\n      ...notebook,\n    }\n\n    this.setState({ notebookList })\n\n    updateNotebookStateToStorage(notebookList[currentNotebook], currentNotebook)\n    // NOTE: Carefuly around here - I kinda rely on the mutation of this.state.notebookList\n  }\n\n  updateNthNotebook (notebook : NotebookState, index : number) : void {\n    const { notebookList } = this.state\n    notebookList[index] = notebook\n\n    this.setState({ notebookList })\n\n    updateNotebookStateToStorage(notebook, index)\n  }\n\n  changeNotebook (index : number) : void {\n    this.setState({ currentNotebook : index })\n    updateAppStateToStorage({ ...this.state, currentNotebook : index })\n  }\n\n  addNotebook (name : string = '') : void {\n    this.setState({\n      notebookList : [ ...this.state.notebookList, createNewNotebook(name) ],\n      currentNotebook : this.state.currentNotebook + 1\n    })\n\n    updateAppStateToStorage({\n      ...this.state,\n      currentScreen : Screen.MAIN,\n      notebookList : [ ...this.state.notebookList, createNewNotebook(name) ],\n      currentNotebook : this.state.currentNotebook + 1\n    })\n  }\n\n  importNotebook (notebook : NotebookState) : void {\n    this.setState({\n      notebookList : [ ...this.state.notebookList, notebook ],\n      currentNotebook : this.state.currentNotebook + 1\n    })\n\n    updateAppStateToStorage({\n      ...this.state,\n      notebookList : [ ...this.state.notebookList, notebook ],\n      currentNotebook : this.state.currentNotebook + 1\n    })\n  }\n\n  removeNotebook (index : number) : void {\n    // if (index === 0) return\n\n    const { notebookList, currentNotebook } = this.state\n    \n    const nearestValidIndex = (i : number) => {\n      if (i < currentNotebook) return currentNotebook - 1\n      if (i > currentNotebook) return currentNotebook\n      if (notebookList.length === 1) return NaN\n      if (i === 0) return i\n      return i - 1\n    }\n    \n    const newIndex : number = nearestValidIndex(index)\n    \n    if (Number.isNaN(newIndex)) return\n\n    notebookList.splice(index, 1)\n\n    this.setState({ notebookList, currentNotebook : newIndex })\n    updateAppStateToStorage({\n      ...this.state,\n      notebookList,\n      currentNotebook : newIndex,\n    })\n  }\n\n  editNotebookName (index : number) : void {\n    const { notebookList } = this.state\n\n    const notebook : NotebookState = notebookList[index]\n\n    notebookList[index] = { ...notebook, editingName : true, persistent : true }\n\n    this.setState({ notebookList })\n    updateNotebookStateToStorage(notebook, index)\n    // updateAppStateToStorage({ ...this.state })\n  }\n\n  changeNotebookName (index : number, name : string) : void {\n    const { notebookList } = this.state\n\n    const notebook : NotebookState = notebookList[index]\n\n    notebookList[index] = { ...notebook, name }\n\n    this.setState({ notebookList })\n    updateNotebookStateToStorage(notebook, index)\n\n    // updateAppStateToStorage({ ...this.state })\n  }\n\n  stopEditingNotebook (index : number) : void {\n    const { notebookList } = this.state\n\n    const notebook : NotebookState = notebookList[index]\n\n    notebookList[index] = { ...notebook, editingName : false }\n\n    this.setState({ notebookList })\n    updateNotebookStateToStorage(notebook, index)\n    // updateAppStateToStorage({ ...this.state })\n  }\n\n  updateSettings (newSettings : GlobalSettings) : void {\n    const { currentNotebook, notebookList } = this.state\n    notebookList[currentNotebook].settings = newSettings\n\n    this.setState({ notebookList : [...notebookList] })\n    updateSettingsInStorage(newSettings)\n  }\n\n  // importWorkspace (state : AppState) : void {\n  //   this.setState(state)\n  //   updateAppStateToStorage(state)\n  // }\n\n  clearWorkspace () : void {\n    if (window.confirm(CLEAR_WORKSPACE_CONFIRMATION)) {\n\n      // localStorage.removeItem('AppState')\n      const { currentNotebook, notebookList } = this.state\n      notebookList[currentNotebook] = InitNotebookState\n\n      this.setState({ notebookList })\n      updateNotebookStateToStorage(InitNotebookState, currentNotebook)\n\n      // updateAppStateToStorage(this.state)\n\n      // this.setState(loadAppStateFromStorage())\n    }\n  }\n\n  toggleDarkMode () : void {\n    const { darkmode } = this.state\n\n    this.setState({ darkmode : ! darkmode })\n    updateAppStateToStorage({ ...this.state, darkmode : ! darkmode })\n  }\n\n}\n\nfunction createNewNotebook (name : string = 'Anonymous Notebook') : NotebookState {\n  return {\n    boxList : [],\n    activeBoxIndex : NaN,\n    focusedBoxIndex : undefined,\n    settings : loadSettingsFromStorage(),\n    // integrationStates : {\n    //   'UNTYPED_LAMBDA' : UNTYPED_LAMBDA_INTEGRATION_STATE,\n    // },\n\n    locked : false,\n    menuOpen : false,\n    \n    __key : Date.now().toString(),\n    name,\n    editingName : false,\n    persistent : true, // TODO: you can change this if explicit save/rename is required for persistency\n  }\n}\n\nfunction createNewNotebookWithBox (name : string = 'Notebook from Link', box : BoxState) : NotebookState {\n  return {\n    boxList : [ box ],\n    activeBoxIndex : 0,\n    focusedBoxIndex : 0,\n    settings : loadSettingsFromStorage(),\n    // integrationStates : {\n    //   'UNTYPED_LAMBDA' : UNTYPED_LAMBDA_INTEGRATION_STATE,\n    // },\n\n    locked : false,\n    menuOpen : false,\n    \n    __key : Date.now().toString(),\n    name,\n    editingName : false,\n    persistent : true, // TODO: you can change this if explicit save/rename is required for persistency\n  }\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}